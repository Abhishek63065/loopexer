<html>
  <head>
    <title>loopexer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css" media="all">
      * {
  user-select: none;
}

html,
body {
  margin: 0;
  padding: 0;
}

body {
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
}

#M {
  position: absolute;
  background: #000;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

#M {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;

  width: 100vw;
  height: 66.66vw;
  background: #000;
}

@media (min-aspect-ratio: 3/2) {
  #M {
    width: 150vh;
    height: 100vh;
  }
}

#HUD {
  visibility: hidden;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  margin: 10px;
}

#T,
#L {
  font-family: monospace;
  padding: 15px;
  line-height: 70px;
  font-size: 60px;
  text-shadow: 1px 1px 3px #000;
}

#L {
  float: right;
  color: #afc;
  transition: opacity 1.2s linear;
  opacity: 0;
}

#L.a {
  opacity: 1;
}

#T {
  float: left;
  border-radius: 10px;
  width: 70px;
  text-align: center;
  transition: color 150ms linear, background-color 300ms linear;
  background: rgba(20, 0, 40, 0.3);
  border: 1px solid rgba(20, 0, 40, 0.3);
}

#T.x {
  background: red;
}

#c {
  padding: 0;
  display: block;
  visibility: hidden;
}

pre {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  color: #8fa;
  position: absolute;
  white-space: pre-wrap;
  font-size: 19px;
  padding: 1em;
}

#B {
  display: inline-block;
  background: #8fa;
  animation: B 1s linear infinite;
}

@keyframes B {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 1;
  }
  51% {
    opacity: 0;
  }
  100% {
    opacity: 0;
  }
}

#end {
  display: none;
}

.won #end {
  display: block;
}

.won #hud {
  display: none;
}

#intro {
  overflow: hidden;
  max-height: 0px;
  transition: max-height 1.2s linear;
}

#intro.a {
  max-height: 100%;
}

.started #intro {
  display: none;
}

.started #C,
.started #HUD {
  visibility: visible;
}

small {
  font-family: monospace;
  font-size: 13px;
  position: absolute;
  right: 0;
  bottom: 15px;
  color: #040;
}

.started small {
  display: none;
}
    </style>
  </head>
  <body>
    <main id="M">
      <div id="HUD">
        <div id="T">&nbsp;</div>
        <div id="L">-</div>
      </div>
      <pre id="intro">Hello, <i>xx142-b2.exe</i>

This is the year 2413,
humanity is enslaved by an alien race for more than two centuries already.

You are an AI weaponized virus built to infiltrate the alien network and deactivate all power generators and weapon systems.

The alien antivirus will detect and delete you after 13 seconds.

But remember: a file is never really deleted. Use the execution backtrace from your previous attempts to break in and destroy the main memory core.

--------------------------------------

Controls:
WASD / Arrows - movement
Backspace     - kill -9 xx142-b2.exe

--------------------------------------

Press any key to continue . . . <b id="B">&nbsp;</b>
</pre>
      <small>Copyright (c) 2019 Ben Clark, Salvatore Previti</small>
      <pre id="end">
Well done <i>xx142-b2.exe</i>,

You deactivated the memory core.

All alien ships are destroyed.
You freed humanity from slavery.



How about a nice game of chess? <b id="B">&nbsp;</b>
    </pre>
      <canvas id="c"></canvas>
    </main>
    <script>
      // Converts Touch events to Mouse Events

var TouchCompat = {
  supported: (
    ('ontouchstart' in document) ||
    (window.DocumentTouch && document instanceof window.DocumentTouch) ||
    (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 0) || //IE 10
    (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 0) || //IE >=11
    false
  ),
  init: function () {
    if (TouchCompat.supported) {
      document.addEventListener("touchstart", touchHandler, true);
      document.addEventListener("touchmove", touchHandler, true);
      document.addEventListener("touchend", touchHandler, true);
      document.addEventListener("touchcancel", touchHandler, true);
    }

    function touchHandler(event) {
      var touches = event.changedTouches,
        first = touches[0],
        type = "";
      switch (event.type) {
        case "touchstart": {
          type = "mousedown"; break;
        }
        case "touchmove": {
          type = "mousemove"; break;
        }
        case "touchend": {
          type = "mouseup"; break;
        }
        default: {
          return;
        }
      }
      var simulatedEvent = document.createEvent("MouseEvent");
      simulatedEvent.initMouseEvent(type, true, true, window, 1,
        first.screenX, first.screenY,
        first.clientX, first.clientY, false,
        false, false, false, 0/*left*/, null);
      first.target.dispatchEvent(simulatedEvent);
    }
  },
  joystick: function (options) {
    options = options || {};
    options.dataOnly = !TouchCompat.supported || options.dataOnly;
    return nipplejs.create(options);
  }
};

(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.nipplejs = f() } })(function () {
  var define, module, exports;
  'use strict';

  // Constants
  var isTouch = !!('ontouchstart' in window);
  var isPointer = window.PointerEvent ? true : false;
  var isMSPointer = window.MSPointerEvent ? true : false;
  var events = {
    touch: {
      start: 'touchstart',
      move: 'touchmove',
      end: 'touchend, touchcancel'
    },
    mouse: {
      start: 'mousedown',
      move: 'mousemove',
      end: 'mouseup'
    },
    pointer: {
      start: 'pointerdown',
      move: 'pointermove',
      end: 'pointerup, pointercancel'
    },
    MSPointer: {
      start: 'MSPointerDown',
      move: 'MSPointerMove',
      end: 'MSPointerUp'
    }
  };
  var toBind;
  var secondBind = {};
  if (isPointer) {
    toBind = events.pointer;
  } else if (isMSPointer) {
    toBind = events.MSPointer;
  } else if (isTouch) {
    toBind = events.touch;
    secondBind = events.mouse;
  } else {
    toBind = events.mouse;
  }

  ///////////////////////
  ///      UTILS      ///
  ///////////////////////

  var u = {};
  u.distance = function (p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt((dx * dx) + (dy * dy));
  };

  u.angle = function (p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return u.degrees(Math.atan2(dy, dx));
  };

  u.findCoord = function (p, d, a) {
    var b = { x: 0, y: 0 };
    a = u.radians(a);
    b.x = p.x - d * Math.cos(a);
    b.y = p.y - d * Math.sin(a);
    return b;
  };

  u.radians = function (a) {
    return a * (Math.PI / 180);
  };

  u.degrees = function (a) {
    return a * (180 / Math.PI);
  };

  u.bindEvt = function (el, arg, handler) {
    var types = arg.split(/[ ,]+/g);
    var type;
    for (var i = 0; i < types.length; i += 1) {
      type = types[i];
      if (el.addEventListener) {
        el.addEventListener(type, handler, false);
      } else if (el.attachEvent) {
        el.attachEvent(type, handler);
      }
    }
  };

  u.unbindEvt = function (el, arg, handler) {
    var types = arg.split(/[ ,]+/g);
    var type;
    for (var i = 0; i < types.length; i += 1) {
      type = types[i];
      if (el.removeEventListener) {
        el.removeEventListener(type, handler);
      } else if (el.detachEvent) {
        el.detachEvent(type, handler);
      }
    }
  };

  u.trigger = function (el, type, data) {
    var evt = new CustomEvent(type, data);
    el.dispatchEvent(evt);
  };

  u.prepareEvent = function (evt) {
    evt.preventDefault();
    return evt.type.match(/^touch/) ? evt.changedTouches : evt;
  };

  u.getScroll = function () {
    var x = (window.pageXOffset !== undefined) ?
      window.pageXOffset :
      (document.documentElement || document.body.parentNode || document.body)
        .scrollLeft;

    var y = (window.pageYOffset !== undefined) ?
      window.pageYOffset :
      (document.documentElement || document.body.parentNode || document.body)
        .scrollTop;
    return {
      x: x,
      y: y
    };
  };

  u.applyPosition = function (el, pos) {
    if (pos.top || pos.right || pos.bottom || pos.left) {
      el.style.top = pos.top;
      el.style.right = pos.right;
      el.style.bottom = pos.bottom;
      el.style.left = pos.left;
    } else {
      el.style.left = pos.x + 'px';
      el.style.top = pos.y + 'px';
    }
  };

  u.getTransitionStyle = function (property, values, time) {
    var obj = u.configStylePropertyObject(property);
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (typeof values === 'string') {
          obj[i] = values + ' ' + time;
        } else {
          var st = '';
          for (var j = 0, max = values.length; j < max; j += 1) {
            st += values[j] + ' ' + time + ', ';
          }
          obj[i] = st.slice(0, -2);
        }
      }
    }
    return obj;
  };

  u.getVendorStyle = function (property, value) {
    var obj = u.configStylePropertyObject(property);
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        obj[i] = value;
      }
    }
    return obj;
  };

  u.configStylePropertyObject = function (prop) {
    var obj = {};
    obj[prop] = '';
    var vendors = ['webkit', 'Moz', 'o'];
    vendors.forEach(function (vendor) {
      obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = '';
    });
    return obj;
  };

  u.extend = function (objA, objB) {
    for (var i in objB) {
      if (objB.hasOwnProperty(i)) {
        objA[i] = objB[i];
      }
    }
    return objA;
  };

  // Overwrite only what's already present
  u.safeExtend = function (objA, objB) {
    var obj = {};
    for (var i in objA) {
      if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {
        obj[i] = objB[i];
      } else if (objA.hasOwnProperty(i)) {
        obj[i] = objA[i];
      }
    }
    return obj;
  };

  // Map for array or unique item.
  u.map = function (ar, fn) {
    if (ar.length) {
      for (var i = 0, max = ar.length; i < max; i += 1) {
        fn(ar[i]);
      }
    } else {
      fn(ar);
    }
  };

  ///////////////////////
  ///   SUPER CLASS   ///
  ///////////////////////

  function Super() { };

  // Basic event system.
  Super.prototype.on = function (arg, cb) {
    var self = this;
    var types = arg.split(/[ ,]+/g);
    var type;
    self._handlers_ = self._handlers_ || {};

    for (var i = 0; i < types.length; i += 1) {
      type = types[i];
      self._handlers_[type] = self._handlers_[type] || [];
      self._handlers_[type].push(cb);
    }
    return self;
  };

  Super.prototype.off = function (type, cb) {
    var self = this;
    self._handlers_ = self._handlers_ || {};

    if (type === undefined) {
      self._handlers_ = {};
    } else if (cb === undefined) {
      self._handlers_[type] = null;
    } else if (self._handlers_[type] &&
      self._handlers_[type].indexOf(cb) >= 0) {
      self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);
    }

    return self;
  };

  Super.prototype.trigger = function (arg, data) {
    var self = this;
    var types = arg.split(/[ ,]+/g);
    var type;
    self._handlers_ = self._handlers_ || {};

    for (var i = 0; i < types.length; i += 1) {
      type = types[i];
      if (self._handlers_[type] && self._handlers_[type].length) {
        self._handlers_[type].forEach(function (handler) {
          handler.call(self, {
            type: type,
            target: self
          }, data);
        });
      }
    }
  };

  // Configuration
  Super.prototype.config = function (options) {
    var self = this;
    self.options = self.defaults || {};
    if (options) {
      self.options = u.safeExtend(self.options, options);
    }
  };

  // Bind internal events.
  Super.prototype.bindEvt = function (el, type) {
    var self = this;
    self._domHandlers_ = self._domHandlers_ || {};

    self._domHandlers_[type] = function () {
      if (typeof self['on' + type] === 'function') {
        self['on' + type].apply(self, arguments);
      } else {
        console.warn('[WARNING] : Missing "on' + type + '" handler.');
      }
    };

    u.bindEvt(el, toBind[type], self._domHandlers_[type]);

    if (secondBind[type]) {
      // Support for both touch and mouse at the same time.
      u.bindEvt(el, secondBind[type], self._domHandlers_[type]);
    }

    return self;
  };

  // Unbind dom events.
  Super.prototype.unbindEvt = function (el, type) {
    var self = this;
    self._domHandlers_ = self._domHandlers_ || {};

    u.unbindEvt(el, toBind[type], self._domHandlers_[type]);

    if (secondBind[type]) {
      // Support for both touch and mouse at the same time.
      u.unbindEvt(el, secondBind[type], self._domHandlers_[type]);
    }

    delete self._domHandlers_[type];

    return this;
  };

  ///////////////////////
  ///   THE NIPPLE    ///
  ///////////////////////

  function Nipple(collection, options) {
    this.identifier = options.identifier;
    this.position = options.position;
    this.frontPosition = options.frontPosition;
    this.collection = collection;

    // Defaults
    this.defaults = {
      size: 100,
      threshold: 0.1,
      color: 'white',
      fadeTime: 250,
      dataOnly: false,
      restJoystick: true,
      restOpacity: 0.5,
      mode: 'dynamic',
      zone: document.body,
      lockX: false,
      lockY: false
    };

    this.config(options);

    // Overwrites
    if (this.options.mode === 'dynamic') {
      this.options.restOpacity = 0;
    }

    this.id = Nipple.id;
    Nipple.id += 1;
    this.buildEl()
      .stylize();

    // Nipple's API.
    this.instance = {
      el: this.ui.el,
      on: this.on.bind(this),
      off: this.off.bind(this),
      show: this.show.bind(this),
      hide: this.hide.bind(this),
      add: this.addToDom.bind(this),
      remove: this.removeFromDom.bind(this),
      destroy: this.destroy.bind(this),
      resetDirection: this.resetDirection.bind(this),
      computeDirection: this.computeDirection.bind(this),
      trigger: this.trigger.bind(this),
      position: this.position,
      frontPosition: this.frontPosition,
      ui: this.ui,
      identifier: this.identifier,
      id: this.id,
      options: this.options
    };

    return this.instance;
  };

  Nipple.prototype = new Super();
  Nipple.constructor = Nipple;
  Nipple.id = 0;

  // Build the dom element of the Nipple instance.
  Nipple.prototype.buildEl = function (options) {
    this.ui = {};

    if (this.options.dataOnly) {
      return this;
    }

    this.ui.el = document.createElement('div');
    this.ui.back = document.createElement('div');
    this.ui.front = document.createElement('div');

    this.ui.el.className = 'nipple collection_' + this.collection.id;
    this.ui.back.className = 'back';
    this.ui.front.className = 'front';

    this.ui.el.setAttribute('id', 'nipple_' + this.collection.id +
      '_' + this.id);

    this.ui.el.appendChild(this.ui.back);
    this.ui.el.appendChild(this.ui.front);

    return this;
  };

  // Apply CSS to the Nipple instance.
  Nipple.prototype.stylize = function () {
    if (this.options.dataOnly) {
      return this;
    }
    var animTime = this.options.fadeTime + 'ms';
    var borderStyle = u.getVendorStyle('borderRadius', '50%');
    var transitStyle = u.getTransitionStyle('transition', 'opacity', animTime);
    var styles = {};
    styles.el = {
      position: 'absolute',
      opacity: this.options.restOpacity,
      display: 'block',
      'zIndex': 999
    };

    styles.back = {
      position: 'absolute',
      display: 'block',
      width: this.options.size + 'px',
      height: this.options.size + 'px',
      marginLeft: -this.options.size / 2 + 'px',
      marginTop: -this.options.size / 2 + 'px',
      background: this.options.color,
      'opacity': '.5'
    };

    styles.front = {
      width: this.options.size / 2 + 'px',
      height: this.options.size / 2 + 'px',
      position: 'absolute',
      display: 'block',
      marginLeft: -this.options.size / 4 + 'px',
      marginTop: -this.options.size / 4 + 'px',
      background: this.options.color,
      'opacity': '.5'
    };

    u.extend(styles.el, transitStyle);
    u.extend(styles.back, borderStyle);
    u.extend(styles.front, borderStyle);

    this.applyStyles(styles);

    return this;
  };

  Nipple.prototype.applyStyles = function (styles) {
    // Apply styles
    for (var i in this.ui) {
      if (this.ui.hasOwnProperty(i)) {
        for (var j in styles[i]) {
          this.ui[i].style[j] = styles[i][j];
        }
      }
    }

    return this;
  };

  // Inject the Nipple instance into DOM.
  Nipple.prototype.addToDom = function () {
    // We're not adding it if we're dataOnly or already in dom.
    if (this.options.dataOnly || document.body.contains(this.ui.el)) {
      return this;
    }
    this.options.zone.appendChild(this.ui.el);
    return this;
  };

  // Remove the Nipple instance from DOM.
  Nipple.prototype.removeFromDom = function () {
    if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
      return this;
    }
    this.options.zone.removeChild(this.ui.el);
    return this;
  };

  // Entirely destroy this nipple
  Nipple.prototype.destroy = function () {
    clearTimeout(this.removeTimeout);
    clearTimeout(this.showTimeout);
    clearTimeout(this.restTimeout);
    this.trigger('destroyed', this.instance);
    this.removeFromDom();
    this.off();
  };

  // Fade in the Nipple instance.
  Nipple.prototype.show = function (cb) {
    var self = this;

    if (self.options.dataOnly) {
      return self;
    }

    clearTimeout(self.removeTimeout);
    clearTimeout(self.showTimeout);
    clearTimeout(self.restTimeout);

    self.addToDom();

    self.restCallback();

    setTimeout(function () {
      self.ui.el.style.opacity = 1;
    }, 0);

    self.showTimeout = setTimeout(function () {
      self.trigger('shown', self.instance);
      if (typeof cb === 'function') {
        cb.call(this);
      }
    }, self.options.fadeTime);

    return self;
  };

  // Fade out the Nipple instance.
  Nipple.prototype.hide = function (cb) {
    var self = this;

    if (self.options.dataOnly) {
      return self;
    }

    self.ui.el.style.opacity = self.options.restOpacity;

    clearTimeout(self.removeTimeout);
    clearTimeout(self.showTimeout);
    clearTimeout(self.restTimeout);

    self.removeTimeout = setTimeout(
      function () {
        var display = self.options.mode === 'dynamic' ? 'none' : 'block';
        self.ui.el.style.display = display;
        if (typeof cb === 'function') {
          cb.call(self);
        }

        self.trigger('hidden', self.instance);
      },
      self.options.fadeTime
    );
    if (self.options.restJoystick) {
      self.restPosition();
    }

    return self;
  };

  Nipple.prototype.restPosition = function (cb) {
    var self = this;
    self.frontPosition = {
      x: 0,
      y: 0
    };
    var animTime = self.options.fadeTime + 'ms';

    var transitStyle = {};
    transitStyle.front = u.getTransitionStyle('transition',
      ['top', 'left'], animTime);

    var styles = { front: {} };
    styles.front = {
      left: self.frontPosition.x + 'px',
      top: self.frontPosition.y + 'px'
    };

    self.applyStyles(transitStyle);
    self.applyStyles(styles);

    self.restTimeout = setTimeout(
      function () {
        if (typeof cb === 'function') {
          cb.call(self);
        }
        self.restCallback();
      },
      self.options.fadeTime
    );
  };

  Nipple.prototype.restCallback = function () {
    var self = this;
    var transitStyle = {};
    transitStyle.front = u.getTransitionStyle('transition', 'none', '');
    self.applyStyles(transitStyle);
    self.trigger('rested', self.instance);
  };

  Nipple.prototype.resetDirection = function () {
    // Fully rebuild the object to let the iteration possible.
    this.direction = {
      x: false,
      y: false,
      angle: false
    };
  };

  Nipple.prototype.computeDirection = function (obj) {
    var rAngle = obj.angle.radian;
    var angle45 = Math.PI / 4;
    var angle90 = Math.PI / 2;
    var direction, directionX, directionY;

    // Angular direction
    //     \  UP /
    //      \   /
    // LEFT       RIGHT
    //      /   \
    //     /DOWN \
    //
    if (
      rAngle > angle45 &&
      rAngle < (angle45 * 3) &&
      !obj.lockX
    ) {
      direction = 'up';
    } else if (
      rAngle > -angle45 &&
      rAngle <= angle45 &&
      !obj.lockY
    ) {
      direction = 'left';
    } else if (
      rAngle > (-angle45 * 3) &&
      rAngle <= -angle45 &&
      !obj.lockX
    ) {
      direction = 'down';
    } else if (!obj.lockY) {
      direction = 'right';
    }

    // Plain direction
    //    UP                 |
    // _______               | RIGHT
    //                  LEFT |
    //   DOWN                |
    if (!obj.lockY) {
      if (rAngle > -angle90 && rAngle < angle90) {
        directionX = 'left';
      } else {
        directionX = 'right';
      }
    }

    if (!obj.lockX) {
      if (rAngle > 0) {
        directionY = 'up';
      } else {
        directionY = 'down';
      }
    }

    if (obj.force > this.options.threshold) {
      var oldDirection = {};
      for (var i in this.direction) {
        if (this.direction.hasOwnProperty(i)) {
          oldDirection[i] = this.direction[i];
        }
      }

      var same = {};

      this.direction = {
        x: directionX,
        y: directionY,
        angle: direction
      };

      obj.direction = this.direction;

      for (var i in oldDirection) {
        if (oldDirection[i] === this.direction[i]) {
          same[i] = true;
        }
      }

      // If all 3 directions are the same, we don't trigger anything.
      if (same.x && same.y && same.angle) {
        return obj;
      }

      if (!same.x || !same.y) {
        this.trigger('plain', obj);
      }

      if (!same.x) {
        this.trigger('plain:' + directionX, obj);
      }

      if (!same.y) {
        this.trigger('plain:' + directionY, obj);
      }

      if (!same.angle) {
        this.trigger('dir dir:' + direction, obj);
      }
    }
    return obj;
  };

  /* global Nipple, Super */

  ///////////////////////////
  ///   THE COLLECTION    ///
  ///////////////////////////

  function Collection(manager, options) {
    var self = this;
    self.nipples = [];
    self.idles = [];
    self.actives = [];
    self.ids = [];
    self.pressureIntervals = {};
    self.manager = manager;
    self.id = Collection.id;
    Collection.id += 1;

    // Defaults
    self.defaults = {
      zone: document.body,
      multitouch: false,
      maxNumberOfNipples: 10,
      mode: 'dynamic',
      position: { top: 0, left: 0 },
      catchDistance: 200,
      size: 100,
      threshold: 0.1,
      color: 'white',
      fadeTime: 250,
      dataOnly: false,
      restJoystick: true,
      restOpacity: 0.5,
      lockX: false,
      lockY: false
    };

    self.config(options);

    // Overwrites
    if (self.options.mode === 'static' || self.options.mode === 'semi') {
      self.options.multitouch = false;
    }

    if (!self.options.multitouch) {
      self.options.maxNumberOfNipples = 1;
    }

    self.updateBox();
    self.prepareNipples();
    self.bindings();
    self.begin();

    return self.nipples;
  }

  Collection.prototype = new Super();
  Collection.constructor = Collection;
  Collection.id = 0;

  Collection.prototype.prepareNipples = function () {
    var self = this;
    var nips = self.nipples;

    // Public API Preparation.
    nips.on = self.on.bind(self);
    nips.off = self.off.bind(self);
    nips.options = self.options;
    nips.destroy = self.destroy.bind(self);
    nips.ids = self.ids;
    nips.id = self.id;
    nips.processOnMove = self.processOnMove.bind(self);
    nips.processOnEnd = self.processOnEnd.bind(self);
    nips.get = function (id) {
      if (id === undefined) {
        return nips[0];
      }
      for (var i = 0, max = nips.length; i < max; i += 1) {
        if (nips[i].identifier === id) {
          return nips[i];
        }
      }
      return false;
    };
  };

  Collection.prototype.bindings = function () {
    var self = this;
    // Touch start event.
    self.bindEvt(self.options.zone, 'start');
    // Avoid native touch actions (scroll, zoom etc...) on the zone.
    self.options.zone.style.touchAction = 'none';
    self.options.zone.style.msTouchAction = 'none';
  };

  Collection.prototype.begin = function () {
    var self = this;
    var opts = self.options;

    // We place our static nipple
    // if needed.
    if (opts.mode === 'static') {
      var nipple = self.createNipple(
        opts.position,
        self.manager.getIdentifier()
      );
      // Add it to the dom.
      nipple.add();
      // Store it in idles.
      self.idles.push(nipple);
    }
  };

  // Nipple Factory
  Collection.prototype.createNipple = function (position, identifier) {
    var self = this;
    var scroll = u.getScroll();
    var toPutOn = {};
    var opts = self.options;

    if (position.x && position.y) {
      toPutOn = {
        x: position.x -
          (scroll.x + self.box.left),
        y: position.y -
          (scroll.y + self.box.top)
      };
    } else if (
      position.top ||
      position.right ||
      position.bottom ||
      position.left
    ) {

      // We need to compute the position X / Y of the joystick.
      var dumb = document.createElement('DIV');
      dumb.style.display = 'hidden';
      dumb.style.top = position.top;
      dumb.style.right = position.right;
      dumb.style.bottom = position.bottom;
      dumb.style.left = position.left;
      dumb.style.position = 'absolute';

      opts.zone.appendChild(dumb);
      var dumbBox = dumb.getBoundingClientRect();
      opts.zone.removeChild(dumb);

      toPutOn = position;
      position = {
        x: dumbBox.left + scroll.x,
        y: dumbBox.top + scroll.y
      };
    }

    var nipple = new Nipple(self, {
      color: opts.color,
      size: opts.size,
      threshold: opts.threshold,
      fadeTime: opts.fadeTime,
      dataOnly: opts.dataOnly,
      restJoystick: opts.restJoystick,
      restOpacity: opts.restOpacity,
      mode: opts.mode,
      identifier: identifier,
      position: position,
      zone: opts.zone,
      frontPosition: {
        x: 0,
        y: 0
      }
    });

    if (!opts.dataOnly) {
      u.applyPosition(nipple.ui.el, toPutOn);
      u.applyPosition(nipple.ui.front, nipple.frontPosition);
    }
    self.nipples.push(nipple);
    self.trigger('added ' + nipple.identifier + ':added', nipple);
    self.manager.trigger('added ' + nipple.identifier + ':added', nipple);

    self.bindNipple(nipple);

    return nipple;
  };

  Collection.prototype.updateBox = function () {
    var self = this;
    self.box = self.options.zone.getBoundingClientRect();
  };

  Collection.prototype.bindNipple = function (nipple) {
    var self = this;
    var type;
    // Bubble up identified events.
    var handler = function (evt, data) {
      // Identify the event type with the nipple's id.
      type = evt.type + ' ' + data.id + ':' + evt.type;
      self.trigger(type, data);
    };

    // When it gets destroyed.
    nipple.on('destroyed', self.onDestroyed.bind(self));

    // Other events that will get bubbled up.
    nipple.on('shown hidden rested dir plain', handler);
    nipple.on('dir:up dir:right dir:down dir:left', handler);
    nipple.on('plain:up plain:right plain:down plain:left', handler);
  };

  Collection.prototype.pressureFn = function (touch, nipple, identifier) {
    var self = this;
    var previousPressure = 0;
    clearInterval(self.pressureIntervals[identifier]);
    // Create an interval that will read the pressure every 100ms
    self.pressureIntervals[identifier] = setInterval(function () {
      var pressure = touch.force || touch.pressure ||
        touch.webkitForce || 0;
      if (pressure !== previousPressure) {
        nipple.trigger('pressure', pressure);
        self.trigger('pressure ' +
          nipple.identifier + ':pressure', pressure);
        previousPressure = pressure;
      }
    }.bind(self), 100);
  };

  Collection.prototype.onstart = function (evt) {
    var self = this;
    var opts = self.options;
    evt = u.prepareEvent(evt);

    // Update the box position
    self.updateBox();

    var process = function (touch) {
      // If we can create new nipples
      // meaning we don't have more active nipples than we should.
      if (self.actives.length < opts.maxNumberOfNipples) {
        self.processOnStart(touch);
      }
    };

    u.map(evt, process);

    // We ask upstream to bind the document
    // on 'move' and 'end'
    self.manager.bindDocument();
    return false;
  };

  Collection.prototype.processOnStart = function (evt) {
    var self = this;
    var opts = self.options;
    var indexInIdles;
    var identifier = self.manager.getIdentifier(evt);
    var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
    var position = {
      x: evt.pageX,
      y: evt.pageY
    };

    var nipple = self.getOrCreate(identifier, position);

    // Update its touch identifier
    if (nipple.identifier !== identifier) {
      self.manager.removeIdentifier(nipple.identifier);
    }
    nipple.identifier = identifier;

    var process = function (nip) {
      // Trigger the start.
      nip.trigger('start', nip);
      self.trigger('start ' + nip.id + ':start', nip);

      nip.show();
      if (pressure > 0) {
        self.pressureFn(evt, nip, nip.identifier);
      }
      // Trigger the first move event.
      self.processOnMove(evt);
    };

    // Transfer it from idles to actives.
    if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {
      self.idles.splice(indexInIdles, 1);
    }

    // Store the nipple in the actives array
    self.actives.push(nipple);
    self.ids.push(nipple.identifier);

    if (opts.mode !== 'semi') {
      process(nipple);
    } else {
      // In semi we check the distance of the touch
      // to decide if we have to reset the nipple
      var distance = u.distance(position, nipple.position);
      if (distance <= opts.catchDistance) {
        process(nipple);
      } else {
        nipple.destroy();
        self.processOnStart(evt);
        return;
      }
    }

    return nipple;
  };

  Collection.prototype.getOrCreate = function (identifier, position) {
    var self = this;
    var opts = self.options;
    var nipple;

    // If we're in static or semi, we might already have an active.
    if (/(semi|static)/.test(opts.mode)) {
      // Get the active one.
      // TODO: Multi-touche for semi and static will start here.
      // Return the nearest one.
      nipple = self.idles[0];
      if (nipple) {
        self.idles.splice(0, 1);
        return nipple;
      }

      if (opts.mode === 'semi') {
        // If we're in semi mode, we need to create one.
        return self.createNipple(position, identifier);
      }

      console.warn('Coudln\'t find the needed nipple.');
      return false;
    }
    // In dynamic, we create a new one.
    nipple = self.createNipple(position, identifier);
    return nipple;
  };

  Collection.prototype.processOnMove = function (evt) {
    var self = this;
    var opts = self.options;
    var identifier = self.manager.getIdentifier(evt);
    var nipple = self.nipples.get(identifier);

    if (!nipple) {
      // This is here just for safety.
      // It shouldn't happen.
      console.error('Found zombie joystick with ID ' + identifier);
      self.manager.removeIdentifier(identifier);
      return;
    }

    nipple.identifier = identifier;

    var size = nipple.options.size / 2;
    var pos = {
      x: evt.pageX,
      y: evt.pageY
    };

    var dist = u.distance(pos, nipple.position);
    var angle = u.angle(pos, nipple.position);
    var rAngle = u.radians(angle);
    var force = dist / size;

    // If distance is bigger than nipple's size
    // we clamp the position.
    if (dist > size) {
      dist = size;
      pos = u.findCoord(nipple.position, dist, angle);
    }

    var xPosition = pos.x - nipple.position.x
    var yPosition = pos.y - nipple.position.y

    if (opts.lockX) {
      yPosition = 0
    }
    if (opts.lockY) {
      xPosition = 0
    }

    nipple.frontPosition = {
      x: xPosition,
      y: yPosition
    };

    if (!opts.dataOnly) {
      u.applyPosition(nipple.ui.front, nipple.frontPosition);
    }

    // Prepare event's datas.
    var toSend = {
      identifier: nipple.identifier,
      position: pos,
      force: force,
      pressure: evt.force || evt.pressure || evt.webkitForce || 0,
      distance: dist,
      angle: {
        radian: rAngle,
        degree: angle
      },
      instance: nipple,
      lockX: opts.lockX,
      lockY: opts.lockY
    };

    // Compute the direction's datas.
    toSend = nipple.computeDirection(toSend);

    // Offset angles to follow units circle.
    toSend.angle = {
      radian: u.radians(180 - angle),
      degree: 180 - angle
    };

    // Send everything to everyone.
    nipple.trigger('move', toSend);
    self.trigger('move ' + nipple.id + ':move', toSend);
  };

  Collection.prototype.processOnEnd = function (evt) {
    var self = this;
    var opts = self.options;
    var identifier = self.manager.getIdentifier(evt);
    var nipple = self.nipples.get(identifier);
    var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);

    if (!nipple) {
      return;
    }

    if (!opts.dataOnly) {
      nipple.hide(function () {
        if (opts.mode === 'dynamic') {
          nipple.trigger('removed', nipple);
          self.trigger('removed ' + nipple.id + ':removed', nipple);
          self.manager
            .trigger('removed ' + nipple.id + ':removed', nipple);
          nipple.destroy();
        }
      });
    }

    // Clear the pressure interval reader
    clearInterval(self.pressureIntervals[nipple.identifier]);

    // Reset the direciton of the nipple, to be able to trigger a new direction
    // on start.
    nipple.resetDirection();

    nipple.trigger('end', nipple);
    self.trigger('end ' + nipple.id + ':end', nipple);

    // Remove identifier from our bank.
    if (self.ids.indexOf(nipple.identifier) >= 0) {
      self.ids.splice(self.ids.indexOf(nipple.identifier), 1);
    }

    // Clean our actives array.
    if (self.actives.indexOf(nipple) >= 0) {
      self.actives.splice(self.actives.indexOf(nipple), 1);
    }

    if (/(semi|static)/.test(opts.mode)) {
      // Transfer nipple from actives to idles
      // if we're in semi or static mode.
      self.idles.push(nipple);
    } else if (self.nipples.indexOf(nipple) >= 0) {
      // Only if we're not in semi or static mode
      // we can remove the instance.
      self.nipples.splice(self.nipples.indexOf(nipple), 1);
    }

    // We unbind move and end.
    self.manager.unbindDocument();

    // We add back the identifier of the idle nipple;
    if (/(semi|static)/.test(opts.mode)) {
      self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
    }
  };

  // Remove destroyed nipple from the lists
  Collection.prototype.onDestroyed = function (evt, nipple) {
    var self = this;
    if (self.nipples.indexOf(nipple) >= 0) {
      self.nipples.splice(self.nipples.indexOf(nipple), 1);
    }
    if (self.actives.indexOf(nipple) >= 0) {
      self.actives.splice(self.actives.indexOf(nipple), 1);
    }
    if (self.idles.indexOf(nipple) >= 0) {
      self.idles.splice(self.idles.indexOf(nipple), 1);
    }
    if (self.ids.indexOf(nipple.identifier) >= 0) {
      self.ids.splice(self.ids.indexOf(nipple.identifier), 1);
    }

    // Remove the identifier from our bank
    self.manager.removeIdentifier(nipple.identifier);

    // We unbind move and end.
    self.manager.unbindDocument();
  };

  // Cleanly destroy the manager
  Collection.prototype.destroy = function () {
    var self = this;
    self.unbindEvt(self.options.zone, 'start');

    // Destroy nipples.
    self.nipples.forEach(function (nipple) {
      nipple.destroy();
    });

    // Clean 3DTouch intervals.
    for (var i in self.pressureIntervals) {
      if (self.pressureIntervals.hasOwnProperty(i)) {
        clearInterval(self.pressureIntervals[i]);
      }
    }

    // Notify the manager passing the instance
    self.trigger('destroyed', self.nipples);
    // We unbind move and end.
    self.manager.unbindDocument();
    // Unbind everything.
    self.off();
  };

  /* global u, Super, Collection */

  ///////////////////////
  ///     MANAGER     ///
  ///////////////////////

  function Manager(options) {
    var self = this;
    self.ids = {};
    self.index = 0;
    self.collections = [];

    self.config(options);
    self.prepareCollections();

    // Listen for resize, to reposition every joysticks
    var resizeTimer;
    u.bindEvt(window, 'resize', function (evt) {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(function () {
        var pos;
        var scroll = u.getScroll();
        self.collections.forEach(function (collection) {
          collection.forEach(function (nipple) {
            pos = nipple.el.getBoundingClientRect();
            nipple.position = {
              x: scroll.x + pos.left,
              y: scroll.y + pos.top
            };
          });
        });
      }, 100);
    });

    return self.collections;
  };

  Manager.prototype = new Super();
  Manager.constructor = Manager;

  Manager.prototype.prepareCollections = function () {
    var self = this;
    // Public API Preparation.
    self.collections.create = self.create.bind(self);
    // Listen to anything
    self.collections.on = self.on.bind(self);
    // Unbind general events
    self.collections.off = self.off.bind(self);
    // Destroy everything
    self.collections.destroy = self.destroy.bind(self);
    // Get any nipple
    self.collections.get = function (id) {
      var nipple;
      self.collections.every(function (collection) {
        if (nipple = collection.get(id)) {
          return false;
        }
        return true;
      });
      return nipple;
    };
  };

  Manager.prototype.create = function (options) {
    return this.createCollection(options);
  };

  // Collection Factory
  Manager.prototype.createCollection = function (options) {
    var self = this;
    var collection = new Collection(self, options);

    self.bindCollection(collection);
    self.collections.push(collection);

    return collection;
  };

  Manager.prototype.bindCollection = function (collection) {
    var self = this;
    var type;
    // Bubble up identified events.
    var handler = function (evt, data) {
      // Identify the event type with the nipple's identifier.
      type = evt.type + ' ' + data.id + ':' + evt.type;
      self.trigger(type, data);
    };

    // When it gets destroyed we clean.
    collection.on('destroyed', self.onDestroyed.bind(self));

    // Other events that will get bubbled up.
    collection.on('shown hidden rested dir plain', handler);
    collection.on('dir:up dir:right dir:down dir:left', handler);
    collection.on('plain:up plain:right plain:down plain:left', handler);
  };

  Manager.prototype.bindDocument = function () {
    var self = this;
    // Bind only if not already binded
    if (!self.binded) {
      self.bindEvt(document, 'move')
        .bindEvt(document, 'end');
      self.binded = true;
    }
  };

  Manager.prototype.unbindDocument = function (force) {
    var self = this;
    // If there are no touch left
    // unbind the document.
    if (!Object.keys(self.ids).length || force === true) {
      self.unbindEvt(document, 'move')
        .unbindEvt(document, 'end');
      self.binded = false;
    }
  };

  Manager.prototype.getIdentifier = function (evt) {
    var id;
    // If no event, simple increment
    if (!evt) {
      id = this.index;
    } else {
      // Extract identifier from event object.
      // Unavailable in mouse events so replaced by latest increment.
      id = evt.identifier === undefined ? evt.pointerId : evt.identifier;
      if (id === undefined) {
        id = this.latest || 0;
      }
    }

    if (this.ids[id] === undefined) {
      this.ids[id] = this.index;
      this.index += 1;
    }

    // Keep the latest id used in case we're using an unidentified mouseEvent
    this.latest = id;
    return this.ids[id];
  };

  Manager.prototype.removeIdentifier = function (identifier) {
    var removed = {};
    for (var id in this.ids) {
      if (this.ids[id] === identifier) {
        removed.id = id;
        removed.identifier = this.ids[id];
        delete this.ids[id];
        break;
      }
    }
    return removed;
  };

  Manager.prototype.onmove = function (evt) {
    var self = this;
    self.onAny('move', evt);
    return false;
  };

  Manager.prototype.onend = function (evt) {
    var self = this;
    self.onAny('end', evt);
    return false;
  };

  Manager.prototype.oncancel = function (evt) {
    var self = this;
    self.onAny('end', evt);
    return false;
  };

  Manager.prototype.onAny = function (which, evt) {
    var self = this;
    var id;
    var processFn = 'processOn' + which.charAt(0).toUpperCase() +
      which.slice(1);
    evt = u.prepareEvent(evt);
    var processColl = function (e, id, coll) {
      if (coll.ids.indexOf(id) >= 0) {
        coll[processFn](e);
        // Mark the event to avoid cleaning it later.
        e._found_ = true;
      }
    };
    var processEvt = function (e) {
      id = self.getIdentifier(e);
      u.map(self.collections, processColl.bind(null, e, id));
      // If the event isn't handled by any collection,
      // we need to clean its identifier.
      if (!e._found_) {
        self.removeIdentifier(id);
      }
    };

    u.map(evt, processEvt);

    return false;
  };

  // Cleanly destroy the manager
  Manager.prototype.destroy = function () {
    var self = this;
    self.unbindDocument(true);
    self.ids = {};
    self.index = 0;
    self.collections.forEach(function (collection) {
      collection.destroy();
    });
    self.off();
  };

  // When a collection gets destroyed
  // we clean behind.
  Manager.prototype.onDestroyed = function (evt, coll) {
    var self = this;
    if (self.collections.indexOf(coll) < 0) {
      return false;
    }
    self.collections.splice(self.collections.indexOf(coll), 1);
  };

  var factory = new Manager();
  return {
    create: function (options) {
      return factory.create(options);
    },
    factory: factory
  };
});
    </script>
    <script>
      const { sin, cos, tan, hypot, atan2, sqrt, abs, floor, round, PI } = Math
const PI2 = PI * 2

const colour = (r, g, b) => [r / 255, g / 255, b / 255]

const clamp01 = t => (t > 0 ? (t > 1 ? 1 : t) : 0)

const angleLerp = (a0, a1, t) => {
  const da = (a1 - a0) % PI2
  return a0 + (((2 * da) % PI2) - da) * clamp01(t)
}

const lerp = (v0, v1, t) => {
  t = clamp01(t)
  return v0 * (1 - t) + v1 * t
}
    </script>
    <script>
      const settings_tps = 20
const settings_timeToDie = 13
const settings_playerRadius = 10
const settings_switchRadius = 15
const settings_playerSpeed = 5
const settings_maxGhosts = 4

const glScale = 1 / 100
const glSwitchRadius = 20
    </script>
    <script>
      function H(){this.A=function(e){for(var f=0;24>f;f++)this[String.fromCharCode(97+f)]=e[f]||0;0.01>this.c&&(this.c=0.01);e=this.b+this.c+this.e;0.18>e&&(e=0.18/e,this.b*=e,this.c*=e,this.e*=e)}}var U=new function(){this.z=new H;var e,f,d,h,j,w,I,J,K,y,k,L;this.reset=function(){var b=this.z;h=100/(b.f*b.f+0.001);j=100/(b.g*b.g+0.001);w=1-0.01*b.h*b.h*b.h;I=1E-6*-b.i*b.i*b.i;b.a||(k=0.5-b.n/2,L=5E-5*-b.o);J=1+b.l*b.l*(0<b.l?-0.9:10);K=0;y=1==b.m?0:2E4*(1-b.m)*(1-b.m)+32};this.C=function(){this.reset();var b=this.z;e=1E5*b.b*b.b;f=1E5*b.c*b.c;d=1E5*b.e*b.e+12;return 3*((e+f+d)/3|0)};this.B=function(b,M){var a=this.z,N=1!=a.s||a.v,o=0.1*a.v*a.v,O=1+3E-4*a.w,l=0.1*a.s*a.s*a.s,V=1+1E-4*a.t,W=1!=a.s,X=a.x*a.x,Y=a.g,P=a.q||a.r,Z=0.2*a.r*a.r*a.r,B=a.q*a.q*(0>a.q?-1020:1020),Q=a.p?(2E4*(1-a.p)*(1-a.p)|0)+32:0,$=a.d,R=a.j/2,aa=0.01*a.k*a.k,C=a.a,D=e,ba=1/e,ca=1/f,da=1/d,a=5/(1+20*a.u*a.u)*(0.01+l);0.8<a&&(a=0.8);for(var a=1-a,E=!1,S=0,s=0,t=0,z=0,q=0,u,r=0,g,m=0,p,F=0,c,T=0,n,G=0,A=Array(1024),v=Array(32),i=A.length;i--;)A[i]=0;for(i=v.length;i--;)v[i]=2*Math.random()-1;for(i=0;i<M;i++){if(E)return i;Q&&++T>=Q&&(T=0,this.reset());y&&++K>=y&&(y=0,h*=J);w+=I;h*=w;h>j&&(h=j,0<Y&&(E=!0));g=h;0<R&&(G+=aa,g*=1+Math.sin(G)*R);g|=0;8>g&&(g=8);C||(k+=L,0>k?k=0:0.5<k&&(k=0.5));if(++s>D)switch(s=0,++S){case 1:D=f;break;case 2:D=d}switch(S){case 0:t=s*ba;break;case 1:t=1+2*(1-s*ca)*$;break;case 2:t=1-s*da;break;case 3:t=0,E=!0}P&&(B+=Z,p=B|0,0>p?p=-p:1023<p&&(p=1023));N&&O&&(o*=O,1E-5>o?o=1E-5:0.1<o&&(o=0.1));n=0;for(var ea=8;ea--;){m++;if(m>=g&&(m%=g,3==C))for(u=v.length;u--;)v[u]=2*Math.random()-1;switch(C){case 0:c=m/g<k?0.5:-0.5;break;case 1:c=1-2*(m/g);break;case 2:c=m/g;c=6.28318531*(0.5<c?c-1:c);c=1.27323954*c+0.405284735*c*c*(0>c?1:-1);c=0.225*((0>c?-1:1)*c*c-c)+c;break;case 3:c=v[Math.abs(32*m/g|0)]}N&&(u=r,l*=V,0>l?l=0:0.1<l&&(l=0.1),W?(q+=(c-r)*l,q*=a):(r=c,q=0),r+=q,z+=r-u,c=z*=1-o);P&&(A[F%1024]=c,c+=A[(F-p+1024)%1024],F++);n+=c}n*=0.125*t*X;b[i]=1<=n?32767:-1>=n?-32768:32767*n|0}return M}};window.jsfxr=function(e){U.z.A(e);var f=U.C(),e=new Uint8Array(4*((f+1)/2|0)+44),f=2*U.B(new Uint16Array(e.buffer,44),f),d=new Uint32Array(e.buffer,0,44);d[0]=1179011410;d[1]=f+36;d[2]=1163280727;d[3]=544501094;d[4]=16;d[5]=65537;d[6]=44100;d[7]=88200;d[8]=1048578;d[9]=1635017060;d[10]=f;for(var f=f+44,d=0,h="data:audio/wav;base64,",x="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";d<f;d+=3)var j=e[d]<<16|e[d+1]<<8|e[d+2],h=h+(x[j>>18]+x[j>>12&63]+x[j>>6&63]+x[j&63]);return h};
    </script>
    <script>
      const shader_basic_vert = `
uniform mat4 Pmatrix;
uniform mat4 Vmatrix;
uniform highp vec3 playerLightPosition;
uniform vec3 inTranslation;
uniform vec3 inAmbientColor;
uniform highp float inFade;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying highp vec3 vColor;
varying highp vec3 vNormal;
varying highp vec3 vPosition;

void main(void) {
  vec3 wp = position + inTranslation;
  gl_Position = Pmatrix * Vmatrix * vec4(wp + vec3(0., 1.-inFade, 0.), 1.);
  vPosition = wp;
  vNormal = normal;
  vColor = color * inAmbientColor * inFade;
}
`

const shader_basic_frag = `
precision mediump float;
uniform highp vec3 playerLightPosition;
uniform float inSurfaceSensitivity;
uniform float inFrameTime;
varying highp vec3 vColor;
varying highp vec3 vNormal;
varying highp vec3 vPosition;

const vec3 AMBIENT_LIGHT = vec3(0.2, 0.2, 0.3);
const vec3 PLAYER_LIGHT_COLOR = vec3(0., 1., 1.);
const vec2 s = vec2(1, 1.7320508);
vec4 getHex(vec2 p){
  vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;
  vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);
  return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + 9.43);
}

float hash21(vec2 p){ return fract(sin(dot(p, vec2(141.173, 289.927)))*43758.5453); }

float hex(vec2 p) {
  vec4 h = getHex(p);
  return sin(hash21(h.zw)*8. + inFrameTime) * 0.5 + 0.5;
}


void main(void) {

  vec3 normal = normalize(vNormal);

  vec3 surfaceToLightDirection = normalize(vPosition - vec3(playerLightPosition.x, -1., playerLightPosition.z));
  float directional = max(dot(normal, surfaceToLightDirection), 0.0);

  float distanceToPlayer2D = distance(vPosition.xz, playerLightPosition.xz);
  float spotLight = max(0.3 - vPosition.y, 0.) * max(0., 1. - distanceToPlayer2D * 1.1);

  vec3 light = vColor * (AMBIENT_LIGHT + vec3(mix(1., directional + spotLight, inSurfaceSensitivity)))
    + vec3(4.5 * spotLight * spotLight * inSurfaceSensitivity);

  if (normal.y > 0.95 && normal.y < 1.05 && vPosition.y  > 0.) {
    light *= mix(0.6, 0.8, 1.-hex(vPosition.xz*5.));
  }

  float fog = 1. - smoothstep(0.1, 10., vPosition.y);
  gl_FragColor = vec4(light * fog, 1.);;
}
`
    </script>
    <script>
      // autogenerated file
const levels = [
  {
    id: 0,
    walls: [
      [
        { x: 384, y: 704 },
        { x: 384, y: 768 },
        { x: 416, y: 800 },
        { x: 480, y: 800 },
        { x: 512, y: 768 },
        { x: 512, y: 704 },
        { x: 480, y: 672 },
        { x: 480, y: 576 },
        { x: 480, y: 480 },
        { x: 480, y: 384 },
        { x: 480, y: 288 },
        { x: 576, y: 288 },
        { x: 576, y: 160 },
        { x: 320, y: 160 },
        { x: 320, y: 288 },
        { x: 416, y: 288 },
        { x: 416, y: 384 },
        { x: 416, y: 480 },
        { x: 416, y: 576 },
        { x: 416, y: 672 },
        { x: 384, y: 704 }
      ]
    ],
    polys: [
      [
        { x: 480, y: 288 },
        { x: 576, y: 288 },
        { x: 576, y: 160 },
        { x: 320, y: 160 },
        { x: 320, y: 288 },
        { x: 416, y: 288 }
      ],
      [
        { x: 384, y: 768 },
        { x: 416, y: 800 },
        { x: 480, y: 800 },
        { x: 512, y: 768 },
        { x: 512, y: 704 },
        { x: 480, y: 672 },
        { x: 416, y: 672 },
        { x: 384, y: 704 }
      ],
      [
        { x: 416, y: 384 },
        { x: 416, y: 480 },
        { x: 416, y: 576 },
        { x: 416, y: 672 },
        { x: 480, y: 672 },
        { x: 480, y: 576 },
        { x: 480, y: 480 },
        { x: 480, y: 384 },
        { x: 480, y: 288 },
        { x: 416, y: 288 }
      ]
    ],
    doors: [
      {
        name: 'door1',
        polygon: [{ x: 416, y: 288 }, { x: 480, y: 288 }, { x: 480, y: 297 }, { x: 416, y: 297 }, { x: 416, y: 288 }],
        open: false
      }
    ],
    switches: [{ uid: 0, x: 448, y: 480, targets: ['door1'], type: 'momentary', pressed: 0 }],
    start: { x: 448, y: 736 },
    end: { x: 448, y: 224 }
  },
  {
    id: 1,
    walls: [
      [
        { x: 288, y: 928 },
        { x: 320, y: 960 },
        { x: 384, y: 960 },
        { x: 416, y: 928 },
        { x: 416, y: 928 },
        { x: 512, y: 928 },
        { x: 544, y: 896 },
        { x: 544, y: 736 },
        { x: 448, y: 640 },
        { x: 448, y: 608 },
        { x: 512, y: 544 },
        { x: 640, y: 544 },
        { x: 640, y: 576 },
        { x: 576, y: 608 },
        { x: 576, y: 704 },
        { x: 704, y: 768 },
        { x: 832, y: 704 },
        { x: 832, y: 608 },
        { x: 768, y: 576 },
        { x: 768, y: 512 },
        { x: 704, y: 448 },
        { x: 512, y: 448 },
        { x: 512, y: 352 },
        { x: 512, y: 352 },
        { x: 544, y: 352 },
        { x: 544, y: 224 },
        { x: 416, y: 224 },
        { x: 416, y: 352 },
        { x: 448, y: 352 },
        { x: 448, y: 448 },
        { x: 320, y: 576 },
        { x: 320, y: 672 },
        { x: 448, y: 800 },
        { x: 448, y: 864 },
        { x: 416, y: 864 },
        { x: 384, y: 832 },
        { x: 320, y: 832 },
        { x: 288, y: 864 },
        { x: 288, y: 928 }
      ]
    ],
    polys: [
      [
        { x: 512, y: 352 },
        { x: 544, y: 352 },
        { x: 544, y: 224 },
        { x: 416, y: 224 },
        { x: 416, y: 352 },
        { x: 448, y: 352 }
      ],
      [
        { x: 640, y: 576 },
        { x: 576, y: 608 },
        { x: 576, y: 704 },
        { x: 704, y: 768 },
        { x: 832, y: 704 },
        { x: 832, y: 608 },
        { x: 768, y: 576 }
      ],
      [
        { x: 416, y: 864 },
        { x: 384, y: 832 },
        { x: 320, y: 832 },
        { x: 288, y: 864 },
        { x: 288, y: 928 },
        { x: 320, y: 960 },
        { x: 384, y: 960 },
        { x: 416, y: 928 }
      ],
      [{ x: 448, y: 864 }, { x: 416, y: 864 }, { x: 416, y: 928 }, { x: 512, y: 928 }],
      [{ x: 768, y: 512 }, { x: 704, y: 448 }, { x: 512, y: 448 }, { x: 512, y: 544 }, { x: 640, y: 544 }],
      [{ x: 640, y: 544 }, { x: 640, y: 576 }, { x: 768, y: 576 }, { x: 768, y: 512 }],
      [
        { x: 320, y: 672 },
        { x: 448, y: 800 },
        { x: 448, y: 640 },
        { x: 448, y: 608 },
        { x: 448, y: 448 },
        { x: 320, y: 576 }
      ],
      [
        { x: 512, y: 352 },
        { x: 448, y: 352 },
        { x: 448, y: 448 },
        { x: 448, y: 608 },
        { x: 512, y: 544 },
        { x: 512, y: 448 }
      ],
      [
        { x: 544, y: 896 },
        { x: 544, y: 736 },
        { x: 448, y: 640 },
        { x: 448, y: 800 },
        { x: 448, y: 864 },
        { x: 512, y: 928 }
      ]
    ],
    doors: [
      {
        name: 'door2',
        polygon: [{ x: 448, y: 352 }, { x: 512, y: 352 }, { x: 512, y: 359 }, { x: 448, y: 359 }, { x: 448, y: 352 }],
        open: false
      },
      { name: 'door1', polygon: [{ x: 448, y: 416 }, { x: 512, y: 416 }, { x: 448, y: 416 }], open: false }
    ],
    switches: [
      { uid: 1, x: 768, y: 672, targets: ['door1'], type: 'momentary', pressed: 0 },
      { uid: 2, x: 640, y: 672, targets: ['door2'], type: 'momentary', pressed: 0 }
    ],
    start: { x: 352, y: 896 },
    end: { x: 480, y: 288 }
  },
  {
    id: 2,
    walls: [
      [
        { x: 416, y: 832 },
        { x: 480, y: 832 },
        { x: 480, y: 672 },
        { x: 576, y: 672 },
        { x: 576, y: 608 },
        { x: 480, y: 608 },
        { x: 480, y: 320 },
        { x: 416, y: 320 },
        { x: 416, y: 608 },
        { x: 320, y: 608 },
        { x: 320, y: 672 },
        { x: 416, y: 672 },
        { x: 416, y: 832 }
      ],
      [{ x: 576, y: 768 }, { x: 576, y: 704 }, { x: 512, y: 704 }, { x: 512, y: 768 }, { x: 576, y: 768 }],
      [{ x: 384, y: 768 }, { x: 384, y: 704 }, { x: 320, y: 704 }, { x: 320, y: 768 }, { x: 384, y: 768 }],
      [{ x: 384, y: 576 }, { x: 384, y: 512 }, { x: 320, y: 512 }, { x: 320, y: 576 }, { x: 384, y: 576 }],
      [{ x: 576, y: 576 }, { x: 576, y: 512 }, { x: 512, y: 512 }, { x: 512, y: 576 }, { x: 576, y: 576 }]
    ],
    polys: [
      [{ x: 416, y: 608 }, { x: 320, y: 608 }, { x: 320, y: 672 }, { x: 416, y: 672 }],
      [{ x: 480, y: 672 }, { x: 576, y: 672 }, { x: 576, y: 608 }, { x: 480, y: 608 }],
      [
        { x: 480, y: 832 },
        { x: 480, y: 672 },
        { x: 480, y: 608 },
        { x: 480, y: 320 },
        { x: 416, y: 320 },
        { x: 416, y: 608 },
        { x: 416, y: 672 },
        { x: 416, y: 832 }
      ],
      [{ x: 576, y: 704 }, { x: 512, y: 704 }, { x: 512, y: 768 }, { x: 576, y: 768 }],
      [{ x: 384, y: 704 }, { x: 320, y: 704 }, { x: 320, y: 768 }, { x: 384, y: 768 }],
      [{ x: 384, y: 512 }, { x: 320, y: 512 }, { x: 320, y: 576 }, { x: 384, y: 576 }],
      [{ x: 576, y: 512 }, { x: 512, y: 512 }, { x: 512, y: 576 }, { x: 576, y: 576 }]
    ],
    doors: [
      { name: 'door1', polygon: [{ x: 416, y: 608 }, { x: 480, y: 608 }, { x: 416, y: 608 }], open: false },
      { name: 'door2', polygon: [{ x: 416, y: 544 }, { x: 480, y: 544 }, { x: 416, y: 544 }], open: false },
      { name: 'door3', polygon: [{ x: 416, y: 480 }, { x: 480, y: 480 }, { x: 416, y: 480 }], open: false },
      { name: 'door4', polygon: [{ x: 416, y: 416 }, { x: 480, y: 416 }, { x: 416, y: 416 }], open: false }
    ],
    switches: [
      { uid: 3, x: 352, y: 640, targets: ['door1', 'door3'], type: 'momentary', pressed: 0 },
      { uid: 4, x: 416, y: 640, targets: ['door3', 'door4'], type: 'momentary', pressed: 0 },
      { uid: 5, x: 480, y: 640, targets: ['door1', 'door2'], type: 'momentary', pressed: 0 },
      { uid: 6, x: 544, y: 640, targets: ['door2', 'door3'], type: 'momentary', pressed: 0 },
      { uid: 7, x: 448, y: 448, targets: ['door4'], type: 'single', pressed: 0 }
    ],
    start: { x: 448, y: 800 },
    end: { x: 448, y: 352 }
  },
  {
    id: 3,
    walls: [
      [
        { x: 448, y: 960 },
        { x: 512, y: 960 },
        { x: 512, y: 864 },
        { x: 512, y: 736 },
        { x: 640, y: 736 },
        { x: 800, y: 736 },
        { x: 800, y: 672 },
        { x: 640, y: 672 },
        { x: 512, y: 672 },
        { x: 512, y: 544 },
        { x: 512, y: 352 },
        { x: 576, y: 352 },
        { x: 640, y: 288 },
        { x: 576, y: 224 },
        { x: 384, y: 224 },
        { x: 320, y: 288 },
        { x: 384, y: 352 },
        { x: 448, y: 352 },
        { x: 448, y: 544 },
        { x: 448, y: 672 },
        { x: 320, y: 672 },
        { x: 192, y: 672 },
        { x: 192, y: 640 },
        { x: 224, y: 608 },
        { x: 352, y: 608 },
        { x: 416, y: 544 },
        { x: 416, y: 448 },
        { x: 352, y: 384 },
        { x: 192, y: 384 },
        { x: 96, y: 480 },
        { x: 96, y: 704 },
        { x: 128, y: 736 },
        { x: 320, y: 736 },
        { x: 448, y: 736 },
        { x: 448, y: 864 },
        { x: 448, y: 960 }
      ]
    ],
    polys: [
      [
        { x: 512, y: 352 },
        { x: 576, y: 352 },
        { x: 640, y: 288 },
        { x: 576, y: 224 },
        { x: 384, y: 224 },
        { x: 320, y: 288 },
        { x: 384, y: 352 },
        { x: 448, y: 352 }
      ],
      [
        { x: 512, y: 672 },
        { x: 512, y: 544 },
        { x: 512, y: 352 },
        { x: 448, y: 352 },
        { x: 448, y: 544 },
        { x: 448, y: 672 }
      ],
      [
        { x: 448, y: 736 },
        { x: 448, y: 864 },
        { x: 448, y: 960 },
        { x: 512, y: 960 },
        { x: 512, y: 864 },
        { x: 512, y: 736 }
      ],
      [{ x: 192, y: 384 }, { x: 96, y: 480 }, { x: 96, y: 704 }, { x: 192, y: 672 }, { x: 192, y: 640 }],
      [{ x: 352, y: 384 }, { x: 192, y: 384 }, { x: 192, y: 640 }, { x: 224, y: 608 }],
      [{ x: 224, y: 608 }, { x: 352, y: 608 }, { x: 416, y: 544 }, { x: 416, y: 448 }, { x: 352, y: 384 }],
      [
        { x: 640, y: 736 },
        { x: 800, y: 736 },
        { x: 800, y: 672 },
        { x: 640, y: 672 },
        { x: 512, y: 672 },
        { x: 448, y: 672 },
        { x: 320, y: 672 },
        { x: 192, y: 672 },
        { x: 96, y: 704 },
        { x: 128, y: 736 },
        { x: 320, y: 736 },
        { x: 448, y: 736 },
        { x: 512, y: 736 }
      ]
    ],
    doors: [
      {
        name: 'door2',
        polygon: [{ x: 448, y: 352 }, { x: 512, y: 352 }, { x: 512, y: 359 }, { x: 448, y: 359 }, { x: 448, y: 352 }],
        open: false
      },
      {
        name: 'door1',
        polygon: [{ x: 448, y: 672 }, { x: 448, y: 736 }, { x: 440, y: 736 }, { x: 440, y: 672 }, { x: 448, y: 672 }],
        open: false
      }
    ],
    switches: [
      { uid: 8, x: 352, y: 512, targets: ['door2'], type: 'momentary', pressed: 0 },
      { uid: 9, x: 769, y: 702, targets: ['door1'], type: 'toggle', pressed: 0 }
    ],
    start: { x: 480, y: 928 },
    end: { x: 480, y: 288 }
  },
  {
    id: 4,
    walls: [[{ x: 416, y: 704 }, { x: 480, y: 704 }, { x: 480, y: 320 }, { x: 416, y: 320 }, { x: 416, y: 704 }]],
    polys: [[{ x: 480, y: 704 }, { x: 480, y: 320 }, { x: 416, y: 320 }, { x: 416, y: 704 }]],
    doors: [
      { name: 'door2', polygon: [{ x: 416, y: 544 }, { x: 480, y: 544 }, { x: 416, y: 544 }], open: false },
      { name: 'door3', polygon: [{ x: 416, y: 480 }, { x: 480, y: 480 }, { x: 416, y: 480 }], open: false },
      { name: 'door4', polygon: [{ x: 416, y: 416 }, { x: 480, y: 416 }, { x: 416, y: 416 }], open: true }
    ],
    switches: [
      { uid: 10, x: 448, y: 448, targets: ['door3', 'door4'], type: 'single', pressed: 0 },
      { uid: 11, x: 448, y: 512, targets: ['door4'], type: 'momentary', pressed: 0 },
      { uid: 12, x: 448, y: 576, targets: ['door2', 'door3'], type: 'momentary', pressed: 0 }
    ],
    start: { x: 448, y: 672 },
    end: { x: 448, y: 384 }
  },
  {
    id: 5,
    walls: [
      [
        { x: 224, y: 160 },
        { x: 224, y: 0 },
        { x: 160, y: 0 },
        { x: 160, y: 160 },
        { x: 96, y: 160 },
        { x: 64, y: 96 },
        { x: 0, y: 96 },
        { x: 0, y: 288 },
        { x: 64, y: 288 },
        { x: 96, y: 224 },
        { x: 160, y: 224 },
        { x: 160, y: 288 },
        { x: 128, y: 288 },
        { x: 160, y: 384 },
        { x: 224, y: 384 },
        { x: 256, y: 288 },
        { x: 224, y: 288 },
        { x: 224, y: 224 },
        { x: 288, y: 224 },
        { x: 320, y: 288 },
        { x: 384, y: 288 },
        { x: 384, y: 96 },
        { x: 320, y: 96 },
        { x: 288, y: 160 },
        { x: 224, y: 160 }
      ]
    ],
    polys: [
      [
        { x: 288, y: 224 },
        { x: 320, y: 288 },
        { x: 384, y: 288 },
        { x: 384, y: 96 },
        { x: 320, y: 96 },
        { x: 288, y: 160 }
      ],
      [
        { x: 160, y: 288 },
        { x: 128, y: 288 },
        { x: 160, y: 384 },
        { x: 224, y: 384 },
        { x: 256, y: 288 },
        { x: 224, y: 288 }
      ],
      [{ x: 160, y: 224 }, { x: 160, y: 288 }, { x: 224, y: 288 }, { x: 224, y: 224 }],
      [{ x: 96, y: 160 }, { x: 64, y: 96 }, { x: 0, y: 96 }, { x: 0, y: 288 }, { x: 64, y: 288 }, { x: 96, y: 224 }],
      [{ x: 224, y: 160 }, { x: 224, y: 0 }, { x: 160, y: 0 }, { x: 160, y: 160 }],
      [
        { x: 160, y: 160 },
        { x: 96, y: 160 },
        { x: 96, y: 224 },
        { x: 160, y: 224 },
        { x: 224, y: 224 },
        { x: 288, y: 224 },
        { x: 288, y: 160 },
        { x: 224, y: 160 }
      ]
    ],
    doors: [
      { name: 'door2', polygon: [{ x: 160, y: 224 }, { x: 224, y: 224 }, { x: 160, y: 224 }], open: false },
      { name: 'door1', polygon: [{ x: 160, y: 160 }, { x: 224, y: 160 }, { x: 160, y: 160 }], open: false },
      { name: 'door3', polygon: [{ x: 160, y: 160 }, { x: 160, y: 224 }, { x: 160, y: 160 }], open: false },
      { name: 'door4', polygon: [{ x: 224, y: 160 }, { x: 224, y: 224 }, { x: 224, y: 160 }], open: true }
    ],
    switches: [
      { uid: 13, x: 352, y: 128, targets: ['door4'], type: 'momentary', pressed: 0 },
      { uid: 14, x: 352, y: 256, targets: ['door4', 'door3'], type: 'momentary', pressed: 0 },
      { uid: 15, x: 32, y: 128, targets: ['door3', 'door2'], type: 'momentary', pressed: 0 },
      { uid: 16, x: 32, y: 256, targets: ['door4', 'door3'], type: 'momentary', pressed: 0 },
      { uid: 17, x: 192, y: 352, targets: ['door2', 'door1'], type: 'momentary', pressed: 0 }
    ],
    start: { x: 192, y: 192 },
    end: { x: 192, y: 32 }
  },
  {
    id: 6,
    walls: [
      [
        { x: 416, y: 960 },
        { x: 480, y: 960 },
        { x: 480, y: 288 },
        { x: 512, y: 288 },
        { x: 576, y: 352 },
        { x: 576, y: 576 },
        { x: 480, y: 672 },
        { x: 480, y: 864 },
        { x: 640, y: 736 },
        { x: 640, y: 192 },
        { x: 480, y: 192 },
        { x: 480, y: 32 },
        { x: 128, y: 32 },
        { x: 128, y: 960 },
        { x: 416, y: 960 },
        { x: 416, y: 864 },
        { x: 256, y: 736 },
        { x: 256, y: 192 },
        { x: 416, y: 192 },
        { x: 256, y: 192 },
        { x: 256, y: 736 },
        { x: 416, y: 864 },
        { x: 416, y: 672 },
        { x: 320, y: 576 },
        { x: 320, y: 352 },
        { x: 384, y: 288 },
        { x: 416, y: 288 },
        { x: 416, y: 960 }
      ],
      [
        { x: 576, y: 352 },
        { x: 512, y: 288 },
        { x: 480, y: 288 },
        { x: 480, y: 672 },
        { x: 576, y: 576 },
        { x: 576, y: 352 }
      ],
      [{ x: 640, y: 192 }, { x: 640, y: 32 }, { x: 480, y: 32 }, { x: 480, y: 192 }, { x: 640, y: 192 }],
      [
        { x: 384, y: 288 },
        { x: 320, y: 352 },
        { x: 320, y: 576 },
        { x: 416, y: 672 },
        { x: 416, y: 288 },
        { x: 384, y: 288 }
      ],
      [{ x: 640, y: 736 }, { x: 480, y: 864 }, { x: 480, y: 960 }, { x: 640, y: 960 }, { x: 640, y: 736 }],
      [{ x: 704, y: 32 }, { x: 640, y: 32 }, { x: 640, y: 960 }, { x: 704, y: 960 }, { x: 704, y: 32 }]
    ],
    polys: [
      [{ x: 256, y: 736 }, { x: 416, y: 864 }, { x: 416, y: 672 }, { x: 320, y: 576 }],
      [{ x: 256, y: 192 }, { x: 256, y: 736 }, { x: 320, y: 576 }, { x: 320, y: 352 }],
      [{ x: 416, y: 192 }, { x: 256, y: 192 }, { x: 320, y: 352 }, { x: 384, y: 288 }],
      [{ x: 416, y: 192 }, { x: 384, y: 288 }, { x: 416, y: 288 }],
      [{ x: 128, y: 960 }, { x: 416, y: 960 }, { x: 416, y: 864 }, { x: 256, y: 736 }],
      [{ x: 128, y: 32 }, { x: 128, y: 960 }, { x: 256, y: 736 }, { x: 256, y: 192 }],
      [{ x: 480, y: 192 }, { x: 480, y: 32 }, { x: 128, y: 32 }, { x: 256, y: 192 }, { x: 416, y: 192 }],
      [
        { x: 480, y: 192 },
        { x: 416, y: 192 },
        { x: 416, y: 288 },
        { x: 416, y: 960 },
        { x: 480, y: 960 },
        { x: 480, y: 288 }
      ],
      [{ x: 640, y: 192 }, { x: 480, y: 192 }, { x: 480, y: 288 }, { x: 512, y: 288 }],
      [{ x: 640, y: 192 }, { x: 512, y: 288 }, { x: 576, y: 352 }],
      [{ x: 640, y: 736 }, { x: 640, y: 192 }, { x: 576, y: 352 }, { x: 576, y: 576 }],
      [{ x: 576, y: 576 }, { x: 480, y: 672 }, { x: 480, y: 864 }, { x: 640, y: 736 }],
      [{ x: 512, y: 288 }, { x: 480, y: 288 }, { x: 480, y: 672 }, { x: 576, y: 576 }, { x: 576, y: 352 }],
      [{ x: 640, y: 32 }, { x: 480, y: 32 }, { x: 480, y: 192 }, { x: 640, y: 192 }],
      [{ x: 320, y: 352 }, { x: 320, y: 576 }, { x: 416, y: 672 }, { x: 416, y: 288 }, { x: 384, y: 288 }],
      [{ x: 640, y: 736 }, { x: 480, y: 864 }, { x: 480, y: 960 }, { x: 640, y: 960 }, { x: 640, y: 736 }],
      [{ x: 704, y: 32 }, { x: 640, y: 32 }, { x: 640, y: 960 }, { x: 704, y: 960 }, { x: 704, y: 32 }]
    ],
    doors: [
      { name: 'door2', polygon: [{ x: 416, y: 416 }, { x: 480, y: 416 }, { x: 416, y: 416 }], open: false },
      { name: 'door1', polygon: [{ x: 416, y: 512 }, { x: 480, y: 512 }, { x: 416, y: 512 }], open: false },
      { name: 'door3', polygon: [{ x: 576, y: 576 }, { x: 640, y: 576 }, { x: 576, y: 576 }], open: false }
    ],
    switches: [
      { uid: 18, x: 448, y: 480, targets: ['door2'], type: 'momentary', pressed: 0 },
      { uid: 19, x: 320, y: 703, targets: ['door3'], type: 'momentary', pressed: 0 },
      { uid: 20, x: 448, y: 576, targets: ['door1'], type: 'momentary', pressed: 0 }
    ],
    start: { x: 448, y: 736 },
    end: { x: 576, y: 703 }
  },
  {
    id: 7,
    walls: [
      [
        { x: 256, y: 128 },
        { x: 96, y: 480 },
        { x: 256, y: 832 },
        { x: 736, y: 832 },
        { x: 896, y: 480 },
        { x: 736, y: 128 },
        { x: 256, y: 128 }
      ],
      [{ x: 338, y: 701 }, { x: 281, y: 797 }, { x: 338, y: 701 }],
      [{ x: 657, y: 699 }, { x: 711, y: 796 }, { x: 657, y: 699 }],
      [
        { x: 448, y: 416 },
        { x: 416, y: 480 },
        { x: 448, y: 544 },
        { x: 544, y: 544 },
        { x: 576, y: 480 },
        { x: 544, y: 416 },
        { x: 576, y: 480 },
        { x: 544, y: 544 },
        { x: 448, y: 544 },
        { x: 416, y: 480 },
        { x: 448, y: 416 }
      ],
      [{ x: 128, y: 480 }, { x: 224, y: 480 }, { x: 128, y: 480 }],
      [{ x: 768, y: 480 }, { x: 864, y: 480 }, { x: 768, y: 480 }],
      [{ x: 654, y: 258 }, { x: 713, y: 163 }, { x: 654, y: 258 }],
      [{ x: 277, y: 163 }, { x: 334, y: 257 }, { x: 277, y: 163 }]
    ],
    polys: [
      [
        { x: 96, y: 480 },
        { x: 256, y: 832 },
        { x: 736, y: 832 },
        { x: 896, y: 480 },
        { x: 736, y: 128 },
        { x: 256, y: 128 }
      ],
      [{ x: 338, y: 701 }, { x: 281, y: 797 }, { x: 338, y: 701 }],
      [{ x: 657, y: 699 }, { x: 711, y: 796 }, { x: 657, y: 699 }],
      [
        { x: 448, y: 416 },
        { x: 416, y: 480 },
        { x: 448, y: 544 },
        { x: 544, y: 544 },
        { x: 576, y: 480 },
        { x: 544, y: 416 },
        { x: 576, y: 480 },
        { x: 544, y: 544 },
        { x: 448, y: 544 },
        { x: 416, y: 480 },
        { x: 448, y: 416 }
      ],
      [{ x: 128, y: 480 }, { x: 224, y: 480 }, { x: 128, y: 480 }],
      [{ x: 768, y: 480 }, { x: 864, y: 480 }, { x: 768, y: 480 }],
      [{ x: 654, y: 258 }, { x: 713, y: 163 }, { x: 654, y: 258 }],
      [{ x: 277, y: 163 }, { x: 334, y: 257 }, { x: 277, y: 163 }]
    ],
    doors: [
      { name: 'l1door', polygon: [{ x: 352, y: 672 }, { x: 640, y: 672 }, { x: 352, y: 672 }], open: false },
      { name: 'l1door_open', polygon: [{ x: 352, y: 672 }, { x: 256, y: 480 }, { x: 352, y: 672 }], open: false },
      { name: 'l1door', polygon: [{ x: 736, y: 480 }, { x: 640, y: 672 }, { x: 736, y: 480 }], open: false },
      { name: 'l1door', polygon: [{ x: 736, y: 480 }, { x: 640, y: 288 }, { x: 736, y: 480 }], open: false },
      { name: 'l1door', polygon: [{ x: 352, y: 288 }, { x: 640, y: 288 }, { x: 352, y: 288 }], open: false },
      { name: 'l1door', polygon: [{ x: 352, y: 288 }, { x: 256, y: 480 }, { x: 352, y: 288 }], open: false },
      { name: 'l2door_open', polygon: [{ x: 416, y: 352 }, { x: 576, y: 352 }, { x: 416, y: 352 }], open: false },
      { name: 'l2door', polygon: [{ x: 640, y: 480 }, { x: 576, y: 352 }, { x: 640, y: 480 }], open: false },
      { name: 'l2door', polygon: [{ x: 640, y: 480 }, { x: 576, y: 608 }, { x: 640, y: 480 }], open: false },
      { name: 'l2door', polygon: [{ x: 416, y: 608 }, { x: 576, y: 608 }, { x: 416, y: 608 }], open: false },
      { name: 'l2door', polygon: [{ x: 416, y: 608 }, { x: 352, y: 480 }, { x: 416, y: 608 }], open: false },
      { name: 'l2door', polygon: [{ x: 416, y: 352 }, { x: 352, y: 480 }, { x: 416, y: 352 }], open: false }
    ],
    switches: [
      { uid: 21, x: 494.074, y: 639.013, targets: ['l2door_open'], type: 'momentary', pressed: 0 },
      { uid: 22, x: 495.676, y: 254.644, targets: ['l1door_open'], type: 'momentary', pressed: 0 }
    ],
    start: { x: 496, y: 720 },
    end: { x: 496, y: 478 },
    last: 1
  }
]
    </script>
    <script>
      const fxr = jsfxr
const move = []
move[0] = new Audio(
  fxr([
    2,
    0.1835,
    0.3165,
    ,
    0.466,
    0.172,
    ,
    -0.0109,
    1,
    0.261,
    0.228,
    0.7,
    0.428,
    0.2505,
    -0.002,
    1,
    -0.2329,
    0.1,
    0.968,
    -0.0003,
    0.413,
    0.1634,
    -0.01,
    0.5
  ])
)
move[0].volume = 0.7
move[1] = move[0].cloneNode()
move[1].volume = 0.7
move[2] = move[0].cloneNode()
move[2].volume = 0.7

const switchDown = new Audio(
  fxr([2, 0.0102, 0.066, 0.539, 0.1037, 0.2835, , -0.189, -0.322, , , 0.8999, , , , , , , 1, , , , , 0.5])
)
const switchUp = new Audio(
  fxr([2, 0.0102, 0.066, 0.539, 0.1037, 0.239, , -0.189, -0.322, , , 0.8999, , , , , , , 1, , , , , 0.5])
)
switchDown.volume = 0.5
switchUp.volume = 0.5

const death = new Audio(fxr([1, , 0.3266, , 0.2971, 0.2594, , 0.2258, , , , , , , , 0.7482, , , 1, , , , , 0.5]))
death.volume = 0.3

const winLevel = new Audio(
  fxr([0, , 0.261, , 0.8055, 0.4874, , 0.1788, , , , , , 0.2292, , 0.4519, , , 1, , , , , 0.5])
)
winLevel.volume = 0.3

let movePlaying = false
let moveIndex = 0

const Sounds = {
  move() {
    if (!movePlaying) {
      movePlaying = true
      moveIndex++
      if (moveIndex == move.length) moveIndex = 0
      move[moveIndex].play()
      setTimeout(() => {
        movePlaying = false
      }, 400)
    }
  },
  switchDown() {
    switchDown.play()
  },
  switchUp() {
    switchUp.play()
  },
  death() {
    death.play()
  },
  win() {
    winLevel.play()
  }
}
    </script>
    <script>
      class Vec2 {
  constructor(x, y) {
    this.x = x
    this.y = y
  }

  add(v) {
    return new Vec2(this.x + v.x, this.y + v.y)
  }

  sub(v) {
    return new Vec2(this.x - v.x, this.y - v.y)
  }

  len() {
    const { x, y } = this
    return sqrt(x * x + y * y)
  }

  mul(n) {
    return new Vec2(this.x * n, this.y * n)
  }

  normal() {
    const len = this.len()
    return new Vec2(-this.y / len, this.x / len)
  }

  normalize() {
    const len = this.len()
    return new Vec2(this.x / len, this.y / len)
  }

  copy() {
    return new Vec2(this.x, this.y)
  }
}

const Vec3 = {
  add: (p1, p2) => [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]],
  sub: (p1, p2) => [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]],
  dot: (p1, p2) => p1[0] * p2[0] + p1[1] * p2[1] + p1[2] * p2[2],
  cross: (p1, p2) => [p1[1] * p2[2] - p1[2] * p2[1], p1[2] * p2[0] - p1[0] * p2[2], p1[0] * p2[1] - p1[1] * p2[0]],
  len: p => sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]),
  normalize: p => {
    const l = Vec3.len(p)
    return [p[0] / l, p[1] / l, p[2] / l]
  },
  mul: (p, n) => [p[0] * n, p[1] * n, p[2] * n]
}
    </script>
    <script>
      const mat4Identity = new Float32Array(16)
mat4Identity[0] = 1
mat4Identity[5] = 1
mat4Identity[10] = 1
mat4Identity[15] = 1

const mat4RotateX = (a, radX) => {
  const s = sin(radX)
  const c = cos(radX)
  const a10 = a[4]
  const a11 = a[5]
  const a12 = a[6]
  const a13 = a[7]
  const a20 = a[8]
  const a21 = a[9]
  const a22 = a[10]
  const a23 = a[11]

  // Perform axis-specific matrix multiplication
  a[4] = a10 * c + a20 * s
  a[5] = a11 * c + a21 * s
  a[6] = a12 * c + a22 * s
  a[7] = a13 * c + a23 * s
  a[8] = a20 * c - a10 * s
  a[9] = a21 * c - a11 * s
  a[10] = a22 * c - a12 * s
  a[11] = a23 * c - a13 * s
}

const mat4RotateY = (a, radY) => {
  const sY = sin(radY)
  const cY = cos(radY)
  const a00 = a[0]
  const a01 = a[1]
  const a02 = a[2]
  const a03 = a[3]
  const a20 = a[8]
  const a21 = a[9]
  const a22 = a[10]
  const a23 = a[11]

  // Perform axis-specific matrix multiplication
  a[0] = a00 * cY - a20 * sY
  a[1] = a01 * cY - a21 * sY
  a[2] = a02 * cY - a22 * sY
  a[3] = a03 * cY - a23 * sY
  a[8] = a00 * sY + a20 * cY
  a[9] = a01 * sY + a21 * cY
  a[10] = a02 * sY + a22 * cY
  a[11] = a03 * sY + a23 * cY
}

const mat4RotateZ = (a, radZ) => {
  const sZ = sin(radZ)
  const cZ = cos(radZ)
  const a00 = a[0]
  const a01 = a[1]
  const a02 = a[2]
  const a03 = a[3]
  const a10 = a[4]
  const a11 = a[5]
  const a12 = a[6]
  const a13 = a[7]

  a[0] = a00 * cZ + a10 * sZ
  a[1] = a01 * cZ + a11 * sZ
  a[2] = a02 * cZ + a12 * sZ
  a[3] = a03 * cZ + a13 * sZ
  a[4] = a10 * cZ - a00 * sZ
  a[5] = a11 * cZ - a01 * sZ
  a[6] = a12 * cZ - a02 * sZ
  a[7] = a13 * cZ - a03 * sZ
}

const mat4Translate = (a, x, y, z) => {
  a[12] = a[0] * x + a[4] * y + a[8] * z + a[12]
  a[13] = a[1] * x + a[5] * y + a[9] * z + a[13]
  a[14] = a[2] * x + a[6] * y + a[10] * z + a[14]
  a[15] = a[3] * x + a[7] * y + a[11] * z + a[15]
}
    </script>
    <script>
      function doesLineInterceptCircle(A, B, C, radius) {
  let dist
  const v1x = B.x - A.x
  const v1y = B.y - A.y
  const v2x = C.x - A.x
  const v2y = C.y - A.y
  // get the unit distance along the line of the closest point to
  // circle center
  const u = (v2x * v1x + v2y * v1y) / (v1y * v1y + v1x * v1x)

  // if the point is on the line segment get the distance squared
  // from that point to the circle center
  if (u >= 0 && u <= 1) {
    dist = (A.x + v1x * u - C.x) ** 2 + (A.y + v1y * u - C.y) ** 2
  } else {
    // if closest point not on the line segment
    // use the unit distance to determine which end is closest
    // and get dist square to circle
    dist = u < 0 ? (A.x - C.x) ** 2 + (A.y - C.y) ** 2 : (B.x - C.x) ** 2 + (B.y - C.y) ** 2
  }
  if (dist < radius * radius) {
    const wall = new Vec2(A.x + v1x * u, A.y + v1y * u) //position on wall
    const vec = C.sub(wall).normalize() //the vector from the wall towards the current circle position
    return wall.add(vec.mul(radius + 0.1)) //return the position that the circle should be in
  }
  return false
}
    </script>
    <script>
      const COLOR_DEEP_WALLS = colour(0, 50, 100)
const COLOR_PILLARS = colour(0, 80, 230)
const COLOR_SMALL_WALLS = colour(0, 100, 255)
const COLOR_GROUND = colour(20, 60, 170)
const COLOR_DOOR = colour(255, 0, 0)
const COLOR_DOOR_SIDE = colour(100, 100, 100)

let builtVertices
let builtNormals
let builtColors
let builtIndices

const builtSprites = {
  player: {},
  ghost: {},
  pad: {},
  core: {}
}

;(() => {
  const vertices = []
  const normals = []
  const colors = []
  const indices = []

  const topNormal = [0, 1, 0]

  const vertexMap = new Map()

  const getVertex = (xyz, color, normal = topNormal) => {
    const key = JSON.stringify([xyz, color, normal])
    let result = vertexMap.get(key)
    if (result === undefined) {
      result = vertexMap.size
      vertexMap.set(key, result)
      vertices.push(-xyz[0] * glScale, xyz[1] * glScale, xyz[2] * glScale)
      colors.push(...color)
      normals.push(...normal)
    }
    return result
  }

  const makeTriangle = (v0, v1, v2, c) => {
    const U = Vec3.sub(v1, v0)
    const V = Vec3.sub(v2, v0)
    const normal = Vec3.cross(U, V)
    indices.push(getVertex(v0, c, normal), getVertex(v1, c, normal), getVertex(v2, c, normal))
  }

  const makeQuad = (v0, v1, v2, v3, c) => {
    makeTriangle(v0, v1, v3, c)
    makeTriangle(v1, v2, v3, c)
  }

  const makePolygon = (vec2s, y, color) => {
    const a = vec2s[0]
    let b = vec2s[1]
    for (let i = 2, c; i < vec2s.length; ++i, b = c) {
      c = vec2s[i]
      makeTriangle([a[0], y, a[1]], [b[0], y, b[1]], [c[0], y, c[1]], color)
    }
  }

  const makePolygonWithWalls = (pts, y0, y1, c, c2 = c) => {
    makePolygon(pts, y0, c)
    let a = pts[0]
    for (let i = 1, b; i <= pts.length; ++i, a = b) {
      b = pts[i % 6]
      makeQuad([a[0], y1, a[1]], [b[0], y1, b[1]], [b[0], y0, b[1]], [a[0], y0, a[1]], c2)
    }
  }

  const makeHexagon = (centerX, centerZ, radius, y0, y1, c, c2, initAngle = 0) => {
    const pts = []
    for (let i = 0; i < 6; ++i) {
      const angle = initAngle + (i / 6) * PI2
      pts.push([sin(angle) * radius + centerX, cos(angle) * radius + centerZ])
    }
    makePolygonWithWalls(pts, y0, y1, c, c2)
  }

  //b and t are each 4 vertexes, anticlockwise (when looking from above) for bottom and top of the shape
  const makeFrustrum = (b, t, c, c2) => {
    //makeQuad(...b, c)
    makeQuad(...t, c)
    makeQuad(b[0], b[1], t[1], t[0], c2 || c)
    makeQuad(b[0], t[0], t[3], b[3], c2 || c)
    makeQuad(b[3], t[3], t[2], b[2], c2 || c)
    makeQuad(b[2], t[2], t[1], b[1], c2 || c)
  }

  for (const level of levels) {
    level.ibStart = indices.length

    const walls = level.walls
    for (const poly of walls) {
      for (let i = 0; i < poly.length; ++i) {
        const poly0 = poly[i]
        const poly1 = poly[(i + 1) % poly.length]

        const a = new Vec2(poly0.x, poly0.y)
        const b = new Vec2(poly1.x, poly1.y)

        const segmentLength = hypot(b.x - a.x, b.y - a.y)
        if (segmentLength === 0) {
          continue
        }

        const xlen = a.x - b.x
        const zlen = a.y - b.y

        const nx = -zlen / segmentLength
        const nz = xlen / segmentLength

        const width = 5
        const topY = -10
        const bottomY = 1
        const deepdown = 1000

        // deep down
        makeQuad([a.x, deepdown, a.y], [b.x, deepdown, b.y], [b.x, bottomY, b.y], [a.x, bottomY, a.y], COLOR_DEEP_WALLS)

        const offset = new Vec2(nx, nz).mul(width / 2)
        const border = [a.sub(offset), b.sub(offset), b.add(offset), a.add(offset)]
        makeFrustrum(
          [
            [border[0].x, bottomY, border[0].y],
            [border[1].x, bottomY, border[1].y],
            [border[2].x, bottomY, border[2].y],
            [border[3].x, bottomY, border[3].y]
          ],
          [
            [border[0].x, topY, border[0].y],
            [border[1].x, topY, border[1].y],
            [border[2].x, topY, border[2].y],
            [border[3].x, topY, border[3].y]
          ],
          COLOR_SMALL_WALLS
        )

        makeHexagon(a.x, a.y, 6, topY - 2, deepdown, COLOR_PILLARS)
      }
    }

    for (const pts of level.polys) {
      const a = pts[0]
      let b = pts[1]
      for (let i = 2; i < pts.length; ++i) {
        const c = pts[i]
        makeTriangle([a.x, 1, a.y], [b.x, 1, b.y], [c.x, 1, c.y], COLOR_GROUND)
        b = c
      }
    }

    for (const d of level.doors) {
      for (let i = 0, p = d.polygon; i < 2; ++i) {
        makeHexagon(p[i].x, p[i].y, 5, -22, 1, COLOR_DOOR_SIDE)
      }
    }

    level.ibCount = indices.length - level.ibStart

    for (const door of level.doors) {
      const p = door.polygon
      const p0 = new Vec2(p[0].x, p[0].y)
      const p1 = new Vec2(p[1].x, p[1].y)
      const normal = p1.sub(p0).normal()
      const offset = normal.mul(1)
      const border = [p0.sub(offset), p1.sub(offset), p1.add(offset), p0.add(offset)]
      door.ibStart = indices.length
      for (let i = 0; i < 2; ++i) {
        const bottomY = -4 - i * 10
        const topY = -6 - i * 10
        makeFrustrum(
          [
            [border[0].x, bottomY, border[0].y],
            [border[1].x, bottomY, border[1].y],
            [border[2].x, bottomY, border[2].y],
            [border[3].x, bottomY, border[3].y]
          ],
          [
            [border[0].x, topY, border[0].y],
            [border[1].x, topY, border[1].y],
            [border[2].x, topY, border[2].y],
            [border[3].x, topY, border[3].y]
          ],
          COLOR_DOOR
        )
      }
      door.ibCount = indices.length - door.ibStart
    }
  }

  builtSprites.player.ibStart = indices.length
  makeTriangle([0, -1, -10], [0, -3, 5], [7, -1, 5], [0.8, 0, 0.8])
  makeTriangle([0, -1, -10], [-7, -1, 5], [0, -3, 5], [0.6, 0, 0.6])
  makeTriangle([0, -3, 5], [-7, -1, 5], [0, -1, 10], [0.5, 0, 0.4])
  makeTriangle([0, -3, 5], [0, -1, 10], [7, -1, 5], [0.7, 0, 0.4])
  builtSprites.player.ibCount = indices.length - builtSprites.player.ibStart

  builtSprites.ghost.ibStart = indices.length
  makeTriangle([0, -1, -10], [0, -1, 5], [7, -1, 5], [0.2, 0, 0.2])
  makeTriangle([0, -1, -10], [-7, -1, 5], [0, -1, 5], [0.15, 0, 0.15])
  makeTriangle([0, -1, 5], [-7, -1, 5], [0, -1, 10], [0.11, 0, 0.1])
  makeTriangle([0, -1, 5], [0, -1, 10], [7, -1, 5], [0.19, 0, 0.1])
  builtSprites.ghost.ibCount = indices.length - builtSprites.ghost.ibStart

  builtSprites.pad.ibStart = indices.length
  makeHexagon(0, 0, glSwitchRadius, -4, 0.1, [1, 1, 1], [0.5, 0.5, 0.5])
  builtSprites.pad.ibCount = indices.length - builtSprites.pad.ibStart

  builtSprites.core.ibStart = indices.length
  for (let i = 0; i < 25; i += 2) {
    const d = i / 5
    makeHexagon(0, 0, glSwitchRadius, -4 - i * 5, 0.1 - i * 5 + d, [1, 1, 1], [0.5, 0.5, 0.5], i)
  }
  builtSprites.core.ibCount = indices.length - builtSprites.core.ibStart

  builtVertices = new Float32Array(vertices)
  builtNormals = new Float32Array(normals)
  builtColors = new Float32Array(colors)
  builtIndices = new Uint16Array(indices)
})()
    </script>
    <script>
      const Drawing = function(canvas) {
  /** @type {WebGLRenderingContext} */
  const gl = canvas.getContext('webgl')
  const elementMain = document.getElementById('M')
  const elementT = document.getElementById('T')

  const createGlBuffer = (items, type = gl.ARRAY_BUFFER) => {
    const result = gl.createBuffer()
    gl.bindBuffer(type, result)
    gl.bufferData(type, items, gl.STATIC_DRAW)
    return result
  }

  const vertex_buffer = createGlBuffer(builtVertices)
  const normal_buffer = createGlBuffer(builtNormals)
  const colors_buffer = createGlBuffer(builtColors)
  const index_buffer = createGlBuffer(builtIndices, gl.ELEMENT_ARRAY_BUFFER)

  let canvasWidth = 0
  let canvasHeight = 0

  const handleResize = () => {
    const w = elementMain.clientWidth
    const h = elementMain.clientHeight
    if (canvasWidth !== w || canvasHeight !== h) {
      canvas.width = canvasWidth = w
      canvas.height = canvasHeight = h
      calcProjectionMatrix()
    }
  }

  let cameraRotX = 1
  let cameraRotY = 0
  let cameraPos = null

  const viewMatrix = new Float32Array(16)
  const projectionMatrix = new Float32Array(16)
  const playerLightPosition = new Float32Array(3)

  handleResize()
  window.addEventListener('resize', handleResize)

  const createGlShasder = (program, input, type) => {
    const shader = gl.createShader(type)
    gl.shaderSource(shader, input)
    gl.compileShader(shader)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.log(`Shader compilation failed: ${gl.getShaderInfoLog(shader)}`)
    }
    gl.attachShader(program, shader)
  }

  const shaderProgram = gl.createProgram()
  createGlShasder(shaderProgram, shader_basic_vert, gl.VERTEX_SHADER)
  createGlShasder(shaderProgram, shader_basic_frag, gl.FRAGMENT_SHADER)
  gl.linkProgram(shaderProgram)

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(shaderProgram))
  }

  /* ====== Associating attributes to vertex shader =====*/
  const uPmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix')
  const uVmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix')
  const uPosition = gl.getAttribLocation(shaderProgram, 'position')
  const uNormal = gl.getAttribLocation(shaderProgram, 'normal')
  const uColor = gl.getAttribLocation(shaderProgram, 'color')
  const uPlayerLightPosition = gl.getUniformLocation(shaderProgram, 'playerLightPosition')
  const uTranslation = gl.getUniformLocation(shaderProgram, 'inTranslation')
  const uAmbientColor = gl.getUniformLocation(shaderProgram, 'inAmbientColor')
  const uSurfaceSensitivity = gl.getUniformLocation(shaderProgram, 'inSurfaceSensitivity')
  const uFrameTime = gl.getUniformLocation(shaderProgram, 'inFrameTime')
  const uFade = gl.getUniformLocation(shaderProgram, 'inFade')

  this.accumulator = 0

  const interpolate = (position, movementVector) => {
    return position.sub(movementVector.mul(1 - settings_tps * this.accumulator))
  }

  this.resetCamera = () => {
    cameraPos = null
  }

  this.setCamera = (position, movementVector) => {
    const currentPlayerPos = interpolate(position, movementVector)
    const desiredCameraPos = [currentPlayerPos.x, 250, -currentPlayerPos.y - 100]

    if (cameraPos === null) {
      cameraPos = desiredCameraPos
    }

    const cameraMovementVector = Vec3.sub(desiredCameraPos, cameraPos)
    const length = Vec3.len(cameraMovementVector)
    if (length > 0) {
      cameraPos = Vec3.add(cameraPos, Vec3.mul(Vec3.normalize(cameraMovementVector), Math.pow(length, 2) * 0.001))
    }

    cameraRotX = 1 + (cameraPos[2] - desiredCameraPos[2]) / 1000
    cameraRotY = -(cameraPos[0] - desiredCameraPos[0]) / 3000

    playerLightPosition[0] = -currentPlayerPos.x * glScale
    playerLightPosition[2] = currentPlayerPos.y * glScale
  }

  this.bg = () => {
    calcViewMatrix()

    gl.enable(gl.DEPTH_TEST)
    gl.depthFunc(gl.LEQUAL)
    gl.clearColor(0, 0, 0, 1)
    gl.clearDepth(1.0)

    gl.viewport(0.0, 0.0, canvasWidth, canvasHeight)
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
  }

  let timerUpdateTime = 0

  let timerR = 0
  let timerG = 0
  let timerS = 0
  let timerX = 0

  this.timer = time => {
    const t = 1 - time / settings_timeToDie

    const s = Math.ceil(13 - time)

    if (timerS !== s || time - timerUpdateTime > 0.2) {
      if (timerX) {
        elementT.className = ''
      }

      timerUpdateTime = time

      let v = new Vec2(t, 1 - t)
      v = v.normalize()

      const r = round(255 * v.y)
      const g = round(255 * v.x)

      if (r !== timerR || g !== timerG) {
        timerR = r
        timerG = g

        const b = round(128 * v.x * v.x)
        elementT.style.color = `rgb(${r},${g},${b})`
      }

      if (timerS !== s) {
        timerS = s
        if (s < 4) {
          timerX = 1
          elementT.className = 'x'
        }
        elementT.innerText = s
      }
    }
  }

  let timeDelta = 1
  let startLight = 0

  const playerRotation = (p, movementVector) => {
    let a
    if (!movementVector || (movementVector.x === 0 && movementVector.y === 0)) {
      a = p._a
    }
    if (a === undefined) {
      a = atan2(-movementVector.y, movementVector.x)
      p._a = a
    }
    let r = p._r
    p._r = r = angleLerp(r !== undefined ? r : a, a, timeDelta * 12)
    return PI / 2 - r
  }

  this.player = player => {
    const pos = interpolate(player.position, player.movementVector)
    calcViewMatrix()
    mat4Translate(viewMatrix, -pos.x * glScale, -3.1 * glScale, pos.y * glScale)
    mat4RotateY(viewMatrix, playerRotation(player, player.drawMovementVector))
    gl.uniformMatrix4fv(uVmatrix, false, viewMatrix)
    gl.uniform3f(uAmbientColor, 1, 1, 1)
    gl.drawElements(gl.TRIANGLES, builtSprites.player.ibCount, gl.UNSIGNED_SHORT, builtSprites.player.ibStart * 2)
  }

  this.ghost = ghost => {
    if (ghost.dead) {
      return false
    }
    const pos = interpolate(ghost.position, ghost.movementVector)
    calcViewMatrix()
    mat4Translate(viewMatrix, -pos.x * glScale, -3 * glScale, pos.y * glScale)
    mat4RotateY(viewMatrix, playerRotation(ghost, ghost.movementVector))
    gl.uniformMatrix4fv(uVmatrix, false, viewMatrix)
    gl.drawElements(gl.TRIANGLES, builtSprites.ghost.ibCount, gl.UNSIGNED_SHORT, builtSprites.ghost.ibStart * 2)
    return true
  }

  let fadeLevel = 0
  let endLight
  let currentLevelId
  let gameState = STATE_FADEOUT
  const levelState = new Map()

  this.level = (level, frameTime, currentTimeDelta, currentCameState) => {
    gameState = currentCameState
    timeDelta = currentTimeDelta
    if (level.id !== currentLevelId) {
      currentLevelId = level.id
      endLight = 0
      levelState.clear()
    }

    fadeLevel = clamp01(fadeLevel + (gameState === STATE_FADEOUT ? -timeDelta : timeDelta))

    gl.enable(gl.CULL_FACE)
    gl.cullFace(gl.BACK)

    gl.useProgram(shaderProgram)

    gl.uniform3f(uTranslation, 0, 0, 0)
    gl.uniform3f(uAmbientColor, 1, 1, 1)
    gl.uniformMatrix4fv(uPmatrix, false, projectionMatrix)
    gl.uniformMatrix4fv(uVmatrix, false, viewMatrix)
    gl.uniform3fv(uPlayerLightPosition, playerLightPosition)
    gl.uniform1f(uFrameTime, frameTime)

    gl.uniform1f(uSurfaceSensitivity, fadeLevel)
    gl.uniform1f(uFade, fadeLevel)

    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer)

    gl.vertexAttribPointer(uPosition, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(uPosition)

    gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer)
    gl.vertexAttribPointer(uNormal, 3, gl.FLOAT, true, 0, 0)
    gl.enableVertexAttribArray(uNormal)

    gl.bindBuffer(gl.ARRAY_BUFFER, colors_buffer)
    gl.vertexAttribPointer(uColor, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(uColor)

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer)

    gl.drawElements(gl.TRIANGLES, level.ibCount, gl.UNSIGNED_SHORT, level.ibStart * 2)

    for (const d of level.doors) {
      if (!d.open) {
        gl.drawElements(gl.TRIANGLES, d.ibCount, gl.UNSIGNED_SHORT, d.ibStart * 2)
      }
    }

    gl.uniform3f(uTranslation, -level.start.x * glScale, glScale, level.start.y * glScale)

    startLight = fadeLevel * clamp01(startLight + timeDelta * (gameState === STATE_FADEIN ? -2 : 3))
    gl.uniform1f(uSurfaceSensitivity, startLight / 3)
    gl.uniform3f(uAmbientColor, 0.2 * startLight, (1 - startLight) / 4, 0.5)
    gl.drawElements(gl.TRIANGLES, builtSprites.pad.ibCount, gl.UNSIGNED_SHORT, builtSprites.pad.ibStart * 2)

    gl.uniform1f(uSurfaceSensitivity, fadeLevel * 0.4)
    gl.uniform3f(uTranslation, -level.end.x * glScale, 3 * glScale, level.end.y * glScale)
    endLight = lerp(endLight, lerp(0.7, 1, 1 - abs(cos(frameTime * 1.5))), timeDelta * 4)
    gl.uniform3f(uAmbientColor, 0, endLight / 1.3, endLight)

    const endSprite = level.last ? builtSprites.core : builtSprites.pad
    gl.drawElements(gl.TRIANGLES, endSprite.ibCount, gl.UNSIGNED_SHORT, endSprite.ibStart * 2)

    for (const s of level.switches) {
      const { uid, pressed } = s
      let switchState = levelState.get(uid)
      if (!switchState) {
        levelState.set(uid, (switchState = { r: 1, g: 0, p: 0 }))
      }

      const { r, g, p } = switchState
      switchState.r = lerp(r, pressed ? 0.1 : lerp(0.7, 1, 1 - abs(cos(frameTime * 3))), timeDelta * 4)
      switchState.g = lerp(g, pressed ? 0.3 : 0, timeDelta * 5)
      switchState.p = lerp(switchState.p, pressed ? 3.8 * glScale : 0, timeDelta * 8)

      gl.uniform1f(uSurfaceSensitivity, fadeLevel * g)

      gl.uniform3f(uTranslation, -s.x * glScale, p, s.y * glScale)
      gl.uniform3f(uAmbientColor, r, g, 0)
      gl.drawElements(gl.TRIANGLES, builtSprites.pad.ibCount, gl.UNSIGNED_SHORT, builtSprites.pad.ibStart * 2)
    }

    gl.uniform1f(uSurfaceSensitivity, 0)
    gl.uniform3f(uTranslation, 0, 0, 0)
  }

  this.titleScreen = () => {}

  this.endScreen = () => {}

  function calcViewMatrix(out = viewMatrix) {
    out.set(mat4Identity)
    mat4RotateX(out, cameraRotX)
    mat4RotateY(out, cameraRotY)
    mat4RotateZ(out, -PI)
    mat4Translate(out, cameraPos[0] * glScale, cameraPos[1] * glScale, cameraPos[2] * glScale)
  }

  function calcProjectionMatrix() {
    const zMin = 0.1
    const zMax = 100
    const a = canvasWidth / canvasHeight
    const angle = 40
    const ang = tan((angle * 0.5 * PI) / 180) //angle*.5
    projectionMatrix[0] = 0.5 / ang
    projectionMatrix[5] = (0.5 * a) / ang
    projectionMatrix[10] = -(zMax + zMin) / (zMax - zMin)
    projectionMatrix[11] = -1
    projectionMatrix[14] = (-2 * zMax * zMin) / (zMax - zMin)
  }
}
    </script>
    <script>
      function Player(level) {
  this.position = level.getStart()
  this.movementVector = new Vec2(0, 0) //stores last movement vector
  this.drawMovementVector = new Vec2(0, -1)

  this.forceMove = v => {
    this.movementVector = v
    this.position = this.position.add(v)

    this.drawMovementVector = this.movementVector.mul(-1) //reverse so we draw correctly
  }

  this.move = buttons => {
    const movement = new Vec2(0, 0)

    if (buttons.up) {
      movement.y -= settings_playerSpeed
    }
    if (buttons.down) {
      movement.y += settings_playerSpeed
    }
    if (buttons.left) {
      movement.x -= settings_playerSpeed
    }
    if (buttons.right) {
      movement.x += settings_playerSpeed
    }
    if (movement.x || movement.y) {
      this.drawMovementVector = movement
    }

    this.movementVector = level.interact(this.position, settings_playerRadius, movement)
    this.position = this.position.add(this.movementVector)
    if (this.movementVector.x || this.movementVector.y) {
      Sounds.move()
    }

    return this.movementVector
  }
}
    </script>
    <script>
      const defaultMovementVector = new Vec2(0, -1)

function Ghost(history, level) {
  this.position = level.getStart()
  //stores the last movementVector
  this.movementVector = defaultMovementVector
  this._a = undefined

  this.tick = currentTick => {
    if (currentTick > history.length) {
      return
    }
    if (currentTick === history.length) {
      level.ghostRemoved(this.position, settings_playerRadius)
      this.dead = true
      return
    }

    const movementVector = history[currentTick]
    level.interact(this.position, settings_playerRadius, movementVector)
    this.position = this.position.add(movementVector) //always apply the vector, cause we're a ghost
    this.movementVector = currentTick === 0 ? defaultMovementVector : movementVector
  }

  this.reset = () => {
    this.position = level.getStart()
    this.dead = false
  }
}
    </script>
    <script>
      function Level(levelObject) {
  let currentLevel = JSON.parse(JSON.stringify(levelObject))

  this.last = !!currentLevel.last

  const doesCircleCollide = (position, radius) => {
    for (let i = 0; i < currentLevel.walls.length; i++) {
      for (let j = 1; j < currentLevel.walls[i].length; j++) {
        const colPos = doesLineInterceptCircle(currentLevel.walls[i][j - 1], currentLevel.walls[i][j], position, radius)
        if (colPos) {
          return doesCircleCollide(colPos, radius) || colPos
        }
      }
    }

    for (let i = 0; i < currentLevel.doors.length; i++) {
      if (currentLevel.doors[i].open) {
        continue
      }
      const colPos = doesLineInterceptCircle(
        currentLevel.doors[i].polygon[0],
        currentLevel.doors[i].polygon[1],
        position,
        radius
      )
      if (colPos) {
        return doesCircleCollide(colPos, radius) || colPos
      }
    }

    return false
  }

  const toggleDoor = doorName => {
    const door = currentLevel.doors.find(d => d.name === doorName)
    door.open = !door.open
  }

  const handleSwitches = (oldPos, newPos, radius) => {
    if (oldPos.x !== newPos.x || oldPos.y !== newPos.y) {
      for (const s of currentLevel.switches) {
        const switchPos = new Vec2(s.x, s.y)
        const wasTouching = oldPos.sub(switchPos).len() < radius + settings_switchRadius
        const nowTouching = newPos.sub(switchPos).len() < radius + settings_switchRadius

        if (!wasTouching && nowTouching) {
          //only toggle if you're the first one on it
          if (s.pressed === 0) {
            for (const target of s.targets) {
              toggleDoor(target)
            }
            Sounds.switchDown()
          }
          s.pressed++
        }
        if (wasTouching && !nowTouching && s.type !== 'single') {
          if (s.pressed <= 0) {
            continue
          }
          s.pressed--
        }
        if (wasTouching && !nowTouching && s.type === 'momentary' && s.pressed === 0) {
          for (const target of s.targets) {
            toggleDoor(target)
          }
        }
        if (wasTouching && !nowTouching && s.pressed === 0) {
          Sounds.switchUp()
        }
      }
    }
  }

  const handleEnd = (position, radius) => {
    const isEnded = position.sub(new Vec2(levelObject.end.x, levelObject.end.y)).len() < radius + settings_switchRadius
    if (isEnded) {
      this.completed = true
    }
  }

  this.ghostRemoved = (position, radius) => {
    for (const s of currentLevel.switches) {
      const isTouching = position.sub(new Vec2(s.x, s.y)).len() < radius + settings_switchRadius
      if (isTouching) {
        if (s.type !== 'single') {
          s.pressed--
        }
        if (s.pressed === 0 && s.type === 'momentary') {
          for (const target of s.targets) {
            toggleDoor(target)
          }
        }
      }
    }
  }

  this.getStart = () => new Vec2(levelObject.start.x, levelObject.start.y)

  this.reset = () => {
    currentLevel = JSON.parse(JSON.stringify(levelObject))
  }

  this.interact = (oldPos, radius, plannedVector) => {
    let newPos = oldPos.add(plannedVector)

    const collisionPosition = doesCircleCollide(newPos, radius)

    newPos = collisionPosition || newPos

    handleSwitches(oldPos, newPos, radius)

    handleEnd(newPos, radius)

    if (collisionPosition) {
      return collisionPosition.sub(oldPos)
    }

    return plannedVector
  }

  this.getLevel = () => currentLevel
}
    </script>
    <script>
      const STATE_TITLE = 0
const STATE_FADEIN = 1
const STATE_PLAY = 2
const STATE_DEAD = 3
const STATE_FADEOUT = 4
const STATE_COMPLETE = 5

function Game(levels) {
  let level
  let player
  let ghosts = []
  let currentTick = 0
  let history = []
  let currentLevel = 0
  let fadeTimer = 0
  let state = STATE_TITLE

  const elementL = document.getElementById('L')

  let levelNameShowed = -1

  function showLevelName() {
    elementL.innerText = level.last ? 'THE MEMORY CORE' : `Level ${currentLevel}`
    elementL.className = 'a'
    setTimeout(() => {
      elementL.className = ''
    }, 2000)
  }

  let buttons = {}

  const reset = () => {
    for (const g of ghosts) {
      g.reset()
    }
    ghosts.push(new Ghost(history, level))
    if (ghosts.length > settings_maxGhosts) {
      ghosts.shift()
    }
    currentTick = 0
    history = []

    //reset level and player
    level.reset()
    player = new Player(level)
    state = STATE_FADEIN
    Draw.scale = 1.5
  }

  const die = () => {
    Sounds.death()
    state = STATE_DEAD
  }

  this.draw = (accumulator, frameTime, timeDelta) => {
    Draw.accumulator = accumulator
    switch (state) {
      case STATE_TITLE:
        Draw.titleScreen()
        break
      case STATE_FADEIN:
      case STATE_FADEOUT:
      case STATE_DEAD:
      case STATE_PLAY:
        Draw.setCamera(player.position, player.movementVector)
        Draw.bg()
        Draw.level(level.getLevel(), frameTime, timeDelta, state)
        Draw.player(player)
        if (state === STATE_PLAY) {
          for (const g of ghosts) {
            Draw.ghost(g)
          }
        }
        Draw.timer(currentTick / settings_tps)
        break
      case STATE_COMPLETE:
        Draw.endScreen()
        break
    }
  }

  this.tick = () => {
    if (state === STATE_FADEIN && levelNameShowed !== currentLevel) {
      levelNameShowed = currentLevel
      showLevelName()
    }

    if (state === STATE_FADEIN || state === STATE_FADEOUT) {
      if (fadeTimer > 0) {
        fadeTimer -= 1 / settings_tps
      }
    }

    if (state === STATE_DEAD) {
      let mv = new Vec2(0, 0)
      while (mv.len() < 40 && currentTick > 0) {
        --currentTick
        mv = mv.sub(history[currentTick])
      }
      Draw.scale /= 0.95
      player.forceMove(mv)
      if (currentTick === 0) {
        reset()
      }
      return
    }

    if (state === STATE_PLAY) {
      if (level.completed) {
        state = STATE_FADEOUT
        player.movementVector = new Vec2(0, 0) //stops flickering while fading out
        fadeTimer = 1.0
        Sounds.win()
        return
      }
      if (currentTick === settings_timeToDie * settings_tps) {
        die()
        return
      }
      history[currentTick] = player.move(buttons)
      for (const g of ghosts) {
        g.tick(currentTick)
      }
      ++currentTick
    }

    if (state === STATE_FADEOUT && fadeTimer <= 0) {
      if (level.last) {
        document.body.className = 'started won'
      } else {
        this.loadLevel(currentLevel + 1)
        state = STATE_FADEIN
        fadeTimer = 1.0
      }
    }
  }

  this.buttonDown = key => {
    if (state === STATE_TITLE) {
      document.body.className = 'started'
      state = STATE_FADEIN
      fadeTimer = 1.0
      return
    }
    if (state === STATE_FADEIN && fadeTimer <= 0) {
      state = STATE_PLAY
    }
    buttons[key] = true
    if (key === 'back') {
      die()
    }
  }

  this.buttonUp = key => {
    if (key === undefined) {
      buttons = {}
    }
    buttons[key] = false
  }

  this.loadLevel = index => {
    currentLevel = index
    if (index >= levels.length) {
      state = STATE_COMPLETE
    }
    level = new Level(levels[index])
    history = []
    player = new Player(level)
    ghosts = []
    currentTick = 0
    Draw.resetCamera()
  }

  this.loadLevel(currentLevel)
}
    </script>
    <script>
      const Draw = new Drawing(document.getElementById('c'))
const game = new Game(levels)

const levelIndex = 0
game.loadLevel(levelIndex)

setTimeout(() => {
  document.getElementById('intro').className = 'a'
}, 1)

let previous
let accumulator = 0 //stores incrementing value (in seconds) until the next tick, when it's then decremented by 1 tick's length
const update = time => {
  requestAnimationFrame(update)
  if (previous === undefined) {
    previous = time
  }
  const dt = (time - previous) / 1000.0
  accumulator += dt

  if (accumulator > 1.0 / settings_tps) {
    accumulator -= 1.0 / settings_tps
    game.tick()
  }
  if (accumulator > 1.0 / settings_tps) {
    accumulator = 1.0 / settings_tps
  }

  game.draw(accumulator, time / 1000.0, dt)

  previous = time
}
requestAnimationFrame(update)

const keyMap = {
  ArrowUp: 'up',
  KeyW: 'up',
  ArrowDown: 'down',
  KeyS: 'down',
  ArrowLeft: 'left',
  KeyA: 'left',
  ArrowRight: 'right',
  KeyD: 'right',
  Backspace: 'back'
}
window.addEventListener('keydown', ev => {
  if (keyMap[ev.code]) {
    game.buttonDown(keyMap[ev.code])
    ev.preventDefault()
  } else {
    game.buttonDown('*') //any-key
  }
  return false
})
window.addEventListener('keyup', ev => {
  if (keyMap[ev.code]) {
    game.buttonUp(keyMap[ev.code])
    ev.preventDefault()
  }
  return false
})

let fullscreen = false
function openFullscreen() {
  if (!fullscreen) {
    document.documentElement.requestFullscreen({ navigationUI: 'hide' })
    fullscreen = true
  }
}

TouchCompat.init()
TouchCompat.joystick().on('move', function (e, data) {
  var angle = data.angle.degree;
  game.buttonUp('up');
  game.buttonUp('down');
  game.buttonUp('left');
  game.buttonUp('right');
  if (data.force > 0.5) {
    var down = 200 <= angle && angle < 340;
    var up = 20 <= angle && angle < 160;
    var left = 110 <= angle && angle < 250;
    var right = (0 <= angle && angle < 70) || (290 <= angle && angle <= 360);
    if (up || down) {
      game.buttonDown(up ? 'up' : 'down')
    }
    if (left || right) {
      game.buttonDown(left ? 'left' : 'right')
    }
  }
}).on('start', function () {
  game.buttonDown('s')
}).on('end', function () {
  openFullscreen();
  game.buttonUp('up');
  game.buttonUp('down');
  game.buttonUp('left');
  game.buttonUp('right');
})
    </script>
  </body>
</html>